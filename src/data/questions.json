[
  {
    "id": 1,
    "title": "Two Sum",
    "slug": "two-sum",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      { "input": "nums = [2,7,11,15], target = 9", "output": "[0,1]", "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]." },
      { "input": "nums = [3,2,4], target = 6", "output": "[1,2]" },
      { "input": "nums = [3,3], target = 6", "output": "[0,1]" }
    ],
    "keywords": ["array", "hash map", "sum", "complement", "two pointers"],
    "hints": [
      "A brute force approach would check every pair of numbers. Can you do better?",
      "Think about what value you need to find for each element — the complement (target - nums[i]).",
      "Use a hash map to store each number's index as you iterate once through the array."
    ],
    "scaffolds": {
      "python": "def twoSum(nums, target):\n    # Return indices of two numbers that add up to target\n    pass\n\n# Example usage:\nprint(twoSum([2, 7, 11, 15], 9))",
      "javascript": "function twoSum(nums, target) {\n  // Return indices of two numbers that add up to target\n}\n\n// Example usage:\nconsole.log(twoSum([2, 7, 11, 15], 9));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc twoSum(nums []int, target int) []int {\n\t// Return indices of two numbers that add up to target\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(twoSum([]int{2, 7, 11, 15}, 9))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[] twoSum(int[] nums, int target) {\n        // Return indices of two numbers that add up to target\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(twoSum(new int[]{2, 7, 11, 15}, 9)));\n    }\n}",
      "rust": "use std::collections::HashMap;\n\nfn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n    // Return indices of two numbers that add up to target\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", two_sum(vec![2, 7, 11, 15], 9));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    // Return indices of two numbers that add up to target\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() {\n    int nums[] = {2, 7, 11, 15};\n    int returnSize;\n    int* result = twoSum(nums, 4, 9, &returnSize);\n    for (int i = 0; i < returnSize; i++) printf(\"%d \", result[i]);\n    free(result);\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& nums, int target) {\n    // Return indices of two numbers that add up to target\n    return {};\n}\n\nint main() {\n    vector<int> nums = {2, 7, 11, 15};\n    auto res = twoSum(nums, 9);\n    for (int x : res) cout << x << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 2,
    "title": "Best Time to Buy and Sell Stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "difficulty": "Easy",
    "category": "Array",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.",
    "examples": [
      { "input": "prices = [7,1,5,3,6,4]", "output": "5", "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5." },
      { "input": "prices = [7,6,4,3,1]", "output": "0", "explanation": "No profitable transaction is possible." }
    ],
    "keywords": ["array", "greedy", "sliding window", "profit", "min tracking"],
    "hints": [
      "You need to find the maximum difference between a later element and an earlier element.",
      "Track the minimum price seen so far as you iterate through the array.",
      "At each step, calculate profit = prices[i] - minPrice, and update the maximum profit."
    ],
    "scaffolds": {
      "python": "def maxProfit(prices):\n    # Return the maximum profit from one buy-sell transaction\n    pass\n\n# Example usage:\nprint(maxProfit([7, 1, 5, 3, 6, 4]))",
      "javascript": "function maxProfit(prices) {\n  // Return the maximum profit from one buy-sell transaction\n}\n\n// Example usage:\nconsole.log(maxProfit([7, 1, 5, 3, 6, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc maxProfit(prices []int) int {\n\t// Return the maximum profit from one buy-sell transaction\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\n}",
      "java": "public class Solution {\n    public static int maxProfit(int[] prices) {\n        // Return the maximum profit from one buy-sell transaction\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxProfit(new int[]{7, 1, 5, 3, 6, 4}));\n    }\n}",
      "rust": "fn max_profit(prices: Vec<i32>) -> i32 {\n    // Return the maximum profit from one buy-sell transaction\n    0\n}\n\nfn main() {\n    println!(\"{}\", max_profit(vec![7, 1, 5, 3, 6, 4]));\n}",
      "c": "#include <stdio.h>\n\nint maxProfit(int* prices, int pricesSize) {\n    // Return the maximum profit from one buy-sell transaction\n    return 0;\n}\n\nint main() {\n    int prices[] = {7, 1, 5, 3, 6, 4};\n    printf(\"%d\\n\", maxProfit(prices, 6));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxProfit(vector<int>& prices) {\n    // Return the maximum profit from one buy-sell transaction\n    return 0;\n}\n\nint main() {\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\n    cout << maxProfit(prices) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 3,
    "title": "Contains Duplicate",
    "slug": "contains-duplicate",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
    "examples": [
      { "input": "nums = [1,2,3,1]", "output": "true" },
      { "input": "nums = [1,2,3,4]", "output": "false" },
      { "input": "nums = [1,1,1,3,3,4,3,2,4,2]", "output": "true" }
    ],
    "keywords": ["array", "hash set", "duplicate", "sorting"],
    "hints": [
      "A brute force approach checks every pair — O(n^2). Can you do better?",
      "Use a hash set to track numbers you've already seen.",
      "If you ever try to insert a number that's already in the set, return true."
    ],
    "scaffolds": {
      "python": "def containsDuplicate(nums):\n    # Return True if any value appears at least twice\n    pass\n\n# Example usage:\nprint(containsDuplicate([1, 2, 3, 1]))",
      "javascript": "function containsDuplicate(nums) {\n  // Return true if any value appears at least twice\n}\n\n// Example usage:\nconsole.log(containsDuplicate([1, 2, 3, 1]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc containsDuplicate(nums []int) bool {\n\t// Return true if any value appears at least twice\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(containsDuplicate([]int{1, 2, 3, 1}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean containsDuplicate(int[] nums) {\n        // Return true if any value appears at least twice\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(containsDuplicate(new int[]{1, 2, 3, 1}));\n    }\n}",
      "rust": "use std::collections::HashSet;\n\nfn contains_duplicate(nums: Vec<i32>) -> bool {\n    // Return true if any value appears at least twice\n    false\n}\n\nfn main() {\n    println!(\"{}\", contains_duplicate(vec![1, 2, 3, 1]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nbool containsDuplicate(int* nums, int numsSize) {\n    // Return true if any value appears at least twice\n    return false;\n}\n\nint main() {\n    int nums[] = {1, 2, 3, 1};\n    printf(\"%s\\n\", containsDuplicate(nums, 4) ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool containsDuplicate(vector<int>& nums) {\n    // Return true if any value appears at least twice\n    return false;\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3, 1};\n    cout << boolalpha << containsDuplicate(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 4,
    "title": "Product of Array Except Self",
    "slug": "product-of-array-except-self",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      { "input": "nums = [1,2,3,4]", "output": "[24,12,8,6]" },
      { "input": "nums = [-1,1,0,-3,3]", "output": "[0,0,9,0,0]" }
    ],
    "keywords": ["array", "prefix", "suffix", "product", "no division"],
    "hints": [
      "Think about computing the product of all elements to the left and to the right of each index separately.",
      "First pass left-to-right: build a prefix product array. Second pass right-to-left: multiply by suffix products.",
      "You can do this in O(1) extra space by using the output array for prefix products, then a running variable for suffix."
    ],
    "scaffolds": {
      "python": "def productExceptSelf(nums):\n    # Return array where each element is product of all others\n    pass\n\n# Example usage:\nprint(productExceptSelf([1, 2, 3, 4]))",
      "javascript": "function productExceptSelf(nums) {\n  // Return array where each element is product of all others\n}\n\n// Example usage:\nconsole.log(productExceptSelf([1, 2, 3, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc productExceptSelf(nums []int) []int {\n\t// Return array where each element is product of all others\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(productExceptSelf([]int{1, 2, 3, 4}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[] productExceptSelf(int[] nums) {\n        // Return array where each element is product of all others\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(productExceptSelf(new int[]{1, 2, 3, 4})));\n    }\n}",
      "rust": "fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n    // Return array where each element is product of all others\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", product_except_self(vec![1, 2, 3, 4]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    // Return array where each element is product of all others\n    *returnSize = numsSize;\n    int* result = (int*)malloc(numsSize * sizeof(int));\n    return result;\n}\n\nint main() {\n    int nums[] = {1, 2, 3, 4};\n    int returnSize;\n    int* res = productExceptSelf(nums, 4, &returnSize);\n    for (int i = 0; i < returnSize; i++) printf(\"%d \", res[i]);\n    free(res);\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> productExceptSelf(vector<int>& nums) {\n    // Return array where each element is product of all others\n    return {};\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3, 4};\n    auto res = productExceptSelf(nums);\n    for (int x : res) cout << x << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 5,
    "title": "Maximum Subarray",
    "slug": "maximum-subarray",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      { "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "6", "explanation": "The subarray [4,-1,2,1] has the largest sum 6." },
      { "input": "nums = [1]", "output": "1" },
      { "input": "nums = [5,4,-1,7,8]", "output": "23" }
    ],
    "keywords": ["array", "dynamic programming", "kadane", "subarray", "greedy"],
    "hints": [
      "Think about this problem element by element. At each position, should you extend the current subarray or start a new one?",
      "Kadane's Algorithm: keep a running sum. If the running sum becomes negative, reset it to 0 (start fresh).",
      "Track two values: currentSum (max sum ending at current position) and maxSum (global maximum). currentSum = max(nums[i], currentSum + nums[i])."
    ],
    "scaffolds": {
      "python": "def maxSubArray(nums):\n    # Return the sum of the maximum subarray\n    pass\n\n# Example usage:\nprint(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))",
      "javascript": "function maxSubArray(nums) {\n  // Return the sum of the maximum subarray\n}\n\n// Example usage:\nconsole.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc maxSubArray(nums []int) int {\n\t// Return the sum of the maximum subarray\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}))\n}",
      "java": "public class Solution {\n    public static int maxSubArray(int[] nums) {\n        // Return the sum of the maximum subarray\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxSubArray(new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4}));\n    }\n}",
      "rust": "fn max_sub_array(nums: Vec<i32>) -> i32 {\n    // Return the sum of the maximum subarray\n    0\n}\n\nfn main() {\n    println!(\"{}\", max_sub_array(vec![-2, 1, -3, 4, -1, 2, 1, -5, 4]));\n}",
      "c": "#include <stdio.h>\n\nint maxSubArray(int* nums, int numsSize) {\n    // Return the sum of the maximum subarray\n    return 0;\n}\n\nint main() {\n    int nums[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    printf(\"%d\\n\", maxSubArray(nums, 9));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxSubArray(vector<int>& nums) {\n    // Return the sum of the maximum subarray\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    cout << maxSubArray(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 6,
    "title": "Maximum Product Subarray",
    "slug": "maximum-product-subarray",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
    "examples": [
      { "input": "nums = [2,3,-2,4]", "output": "6", "explanation": "The subarray [2,3] has the largest product 6." },
      { "input": "nums = [-2,0,-1]", "output": "0", "explanation": "The result cannot be 2, because [-2,-1] is not a subarray." }
    ],
    "keywords": ["array", "dynamic programming", "product", "subarray", "negative numbers"],
    "hints": [
      "Unlike maximum subarray sum, a negative number can become the maximum when multiplied by another negative.",
      "Track both the current maximum product and current minimum product at each position.",
      "At each element: newMax = max(nums[i], maxSoFar * nums[i], minSoFar * nums[i]). Similarly for newMin."
    ],
    "scaffolds": {
      "python": "def maxProduct(nums):\n    # Return the largest product of a contiguous subarray\n    pass\n\n# Example usage:\nprint(maxProduct([2, 3, -2, 4]))",
      "javascript": "function maxProduct(nums) {\n  // Return the largest product of a contiguous subarray\n}\n\n// Example usage:\nconsole.log(maxProduct([2, 3, -2, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc maxProduct(nums []int) int {\n\t// Return the largest product of a contiguous subarray\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(maxProduct([]int{2, 3, -2, 4}))\n}",
      "java": "public class Solution {\n    public static int maxProduct(int[] nums) {\n        // Return the largest product of a contiguous subarray\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxProduct(new int[]{2, 3, -2, 4}));\n    }\n}",
      "rust": "fn max_product(nums: Vec<i32>) -> i32 {\n    // Return the largest product of a contiguous subarray\n    0\n}\n\nfn main() {\n    println!(\"{}\", max_product(vec![2, 3, -2, 4]));\n}",
      "c": "#include <stdio.h>\n\nint maxProduct(int* nums, int numsSize) {\n    // Return the largest product of a contiguous subarray\n    return 0;\n}\n\nint main() {\n    int nums[] = {2, 3, -2, 4};\n    printf(\"%d\\n\", maxProduct(nums, 4));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxProduct(vector<int>& nums) {\n    // Return the largest product of a contiguous subarray\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {2, 3, -2, 4};\n    cout << maxProduct(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 7,
    "title": "Find Minimum in Rotated Sorted Array",
    "slug": "find-minimum-in-rotated-sorted-array",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`.\n\nGiven the sorted rotated array `nums` of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
    "examples": [
      { "input": "nums = [3,4,5,1,2]", "output": "1", "explanation": "The original array was [1,2,3,4,5] rotated 3 times." },
      { "input": "nums = [4,5,6,7,0,1,2]", "output": "0" },
      { "input": "nums = [11,13,15,17]", "output": "11" }
    ],
    "keywords": ["array", "binary search", "rotated", "sorted", "minimum"],
    "hints": [
      "O(log n) means binary search. How can you decide which half to search?",
      "If nums[mid] > nums[right], the minimum is in the right half. Otherwise, it's in the left half (including mid).",
      "Narrow the search space until left == right. That element is the minimum."
    ],
    "scaffolds": {
      "python": "def findMin(nums):\n    # Return the minimum element in a rotated sorted array\n    pass\n\n# Example usage:\nprint(findMin([3, 4, 5, 1, 2]))",
      "javascript": "function findMin(nums) {\n  // Return the minimum element in a rotated sorted array\n}\n\n// Example usage:\nconsole.log(findMin([3, 4, 5, 1, 2]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc findMin(nums []int) int {\n\t// Return the minimum element in a rotated sorted array\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(findMin([]int{3, 4, 5, 1, 2}))\n}",
      "java": "public class Solution {\n    public static int findMin(int[] nums) {\n        // Return the minimum element in a rotated sorted array\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(findMin(new int[]{3, 4, 5, 1, 2}));\n    }\n}",
      "rust": "fn find_min(nums: Vec<i32>) -> i32 {\n    // Return the minimum element in a rotated sorted array\n    0\n}\n\nfn main() {\n    println!(\"{}\", find_min(vec![3, 4, 5, 1, 2]));\n}",
      "c": "#include <stdio.h>\n\nint findMin(int* nums, int numsSize) {\n    // Return the minimum element in a rotated sorted array\n    return 0;\n}\n\nint main() {\n    int nums[] = {3, 4, 5, 1, 2};\n    printf(\"%d\\n\", findMin(nums, 5));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findMin(vector<int>& nums) {\n    // Return the minimum element in a rotated sorted array\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {3, 4, 5, 1, 2};\n    cout << findMin(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 8,
    "title": "Search in Rotated Sorted Array",
    "slug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "category": "Array",
    "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      { "input": "nums = [4,5,6,7,0,1,2], target = 0", "output": "4" },
      { "input": "nums = [4,5,6,7,0,1,2], target = 3", "output": "-1" },
      { "input": "nums = [1], target = 0", "output": "-1" }
    ],
    "keywords": ["array", "binary search", "rotated", "sorted", "search"],
    "hints": [
      "Use binary search. At each step, one half of the array is always sorted.",
      "Determine which half is sorted by comparing nums[left] with nums[mid]. Then check if target lies in the sorted half.",
      "If target is in the sorted half, search there. Otherwise, search the other half."
    ],
    "scaffolds": {
      "python": "def search(nums, target):\n    # Return the index of target, or -1 if not found\n    pass\n\n# Example usage:\nprint(search([4, 5, 6, 7, 0, 1, 2], 0))",
      "javascript": "function search(nums, target) {\n  // Return the index of target, or -1 if not found\n}\n\n// Example usage:\nconsole.log(search([4, 5, 6, 7, 0, 1, 2], 0));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc search(nums []int, target int) int {\n\t// Return the index of target, or -1 if not found\n\treturn -1\n}\n\nfunc main() {\n\tfmt.Println(search([]int{4, 5, 6, 7, 0, 1, 2}, 0))\n}",
      "java": "public class Solution {\n    public static int search(int[] nums, int target) {\n        // Return the index of target, or -1 if not found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(search(new int[]{4, 5, 6, 7, 0, 1, 2}, 0));\n    }\n}",
      "rust": "fn search(nums: Vec<i32>, target: i32) -> i32 {\n    // Return the index of target, or -1 if not found\n    -1\n}\n\nfn main() {\n    println!(\"{}\", search(vec![4, 5, 6, 7, 0, 1, 2], 0));\n}",
      "c": "#include <stdio.h>\n\nint search(int* nums, int numsSize, int target) {\n    // Return the index of target, or -1 if not found\n    return -1;\n}\n\nint main() {\n    int nums[] = {4, 5, 6, 7, 0, 1, 2};\n    printf(\"%d\\n\", search(nums, 7, 0));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint search(vector<int>& nums, int target) {\n    // Return the index of target, or -1 if not found\n    return -1;\n}\n\nint main() {\n    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};\n    cout << search(nums, 0) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 9,
    "title": "3Sum",
    "slug": "3sum",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
    "examples": [
      { "input": "nums = [-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]" },
      { "input": "nums = [0,1,1]", "output": "[]" },
      { "input": "nums = [0,0,0]", "output": "[[0,0,0]]" }
    ],
    "keywords": ["array", "two pointers", "sorting", "sum", "triplet", "duplicate"],
    "hints": [
      "Sort the array first. Then for each element, the problem reduces to finding two numbers that sum to the negative of that element.",
      "Use two pointers (left and right) for the inner search after fixing one element.",
      "Skip duplicate values for all three positions to avoid duplicate triplets."
    ],
    "scaffolds": {
      "python": "def threeSum(nums):\n    # Return all unique triplets that sum to zero\n    pass\n\n# Example usage:\nprint(threeSum([-1, 0, 1, 2, -1, -4]))",
      "javascript": "function threeSum(nums) {\n  // Return all unique triplets that sum to zero\n}\n\n// Example usage:\nconsole.log(threeSum([-1, 0, 1, 2, -1, -4]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc threeSum(nums []int) [][]int {\n\t// Return all unique triplets that sum to zero\n\tsort.Ints(nums)\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(threeSum([]int{-1, 0, 1, 2, -1, -4}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static List<List<Integer>> threeSum(int[] nums) {\n        // Return all unique triplets that sum to zero\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(threeSum(new int[]{-1, 0, 1, 2, -1, -4}));\n    }\n}",
      "rust": "fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n    // Return all unique triplets that sum to zero\n    nums.sort();\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", three_sum(vec![-1, 0, 1, 2, -1, -4]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) { return *(int*)a - *(int*)b; }\n\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    // Return all unique triplets that sum to zero\n    qsort(nums, numsSize, sizeof(int), cmp);\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() {\n    int nums[] = {-1, 0, 1, 2, -1, -4};\n    int returnSize;\n    int* colSizes;\n    int** res = threeSum(nums, 6, &returnSize, &colSizes);\n    printf(\"Found %d triplets\\n\", returnSize);\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> threeSum(vector<int>& nums) {\n    // Return all unique triplets that sum to zero\n    sort(nums.begin(), nums.end());\n    return {};\n}\n\nint main() {\n    vector<int> nums = {-1, 0, 1, 2, -1, -4};\n    auto res = threeSum(nums);\n    for (auto& t : res) {\n        for (int x : t) cout << x << \" \";\n        cout << endl;\n    }\n    return 0;\n}"
    }
  },
  {
    "id": 10,
    "title": "Container With Most Water",
    "slug": "container-with-most-water",
    "difficulty": "Medium",
    "category": "Array",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.",
    "examples": [
      { "input": "height = [1,8,6,2,5,4,8,3,7]", "output": "49", "explanation": "The lines at index 1 and 8 form a container of area min(8,7) * (8-1) = 49." },
      { "input": "height = [1,1]", "output": "1" }
    ],
    "keywords": ["array", "two pointers", "greedy", "water", "area"],
    "hints": [
      "Start with two pointers at the beginning and end of the array for maximum width.",
      "The area is limited by the shorter line. Move the pointer at the shorter line inward to potentially find a taller line.",
      "Calculate area at each step: min(height[left], height[right]) * (right - left). Track the maximum."
    ],
    "scaffolds": {
      "python": "def maxArea(height):\n    # Return the maximum water a container can store\n    pass\n\n# Example usage:\nprint(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]))",
      "javascript": "function maxArea(height) {\n  // Return the maximum water a container can store\n}\n\n// Example usage:\nconsole.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc maxArea(height []int) int {\n\t// Return the maximum water a container can store\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7}))\n}",
      "java": "public class Solution {\n    public static int maxArea(int[] height) {\n        // Return the maximum water a container can store\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxArea(new int[]{1, 8, 6, 2, 5, 4, 8, 3, 7}));\n    }\n}",
      "rust": "fn max_area(height: Vec<i32>) -> i32 {\n    // Return the maximum water a container can store\n    0\n}\n\nfn main() {\n    println!(\"{}\", max_area(vec![1, 8, 6, 2, 5, 4, 8, 3, 7]));\n}",
      "c": "#include <stdio.h>\n\nint maxArea(int* height, int heightSize) {\n    // Return the maximum water a container can store\n    return 0;\n}\n\nint main() {\n    int height[] = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    printf(\"%d\\n\", maxArea(height, 9));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxArea(vector<int>& height) {\n    // Return the maximum water a container can store\n    return 0;\n}\n\nint main() {\n    vector<int> height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout << maxArea(height) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 11,
    "title": "Sum of Two Integers",
    "slug": "sum-of-two-integers",
    "difficulty": "Medium",
    "category": "Binary",
    "description": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.",
    "examples": [
      { "input": "a = 1, b = 2", "output": "3" },
      { "input": "a = 2, b = 3", "output": "5" }
    ],
    "keywords": ["binary", "bit manipulation", "xor", "carry", "addition"],
    "hints": [
      "XOR (^) gives the sum without carry. AND (&) gives the carry bits.",
      "Shift the carry left by 1 and repeat until there is no carry.",
      "a ^ b computes sum ignoring carry; (a & b) << 1 computes the carry. Repeat with these new values."
    ],
    "scaffolds": {
      "python": "def getSum(a, b):\n    # Return the sum without using + or -\n    pass\n\n# Example usage:\nprint(getSum(1, 2))",
      "javascript": "function getSum(a, b) {\n  // Return the sum without using + or -\n}\n\n// Example usage:\nconsole.log(getSum(1, 2));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc getSum(a int, b int) int {\n\t// Return the sum without using + or -\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(getSum(1, 2))\n}",
      "java": "public class Solution {\n    public static int getSum(int a, int b) {\n        // Return the sum without using + or -\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getSum(1, 2));\n    }\n}",
      "rust": "fn get_sum(a: i32, b: i32) -> i32 {\n    // Return the sum without using + or -\n    0\n}\n\nfn main() {\n    println!(\"{}\", get_sum(1, 2));\n}",
      "c": "#include <stdio.h>\n\nint getSum(int a, int b) {\n    // Return the sum without using + or -\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", getSum(1, 2));\n    return 0;\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nint getSum(int a, int b) {\n    // Return the sum without using + or -\n    return 0;\n}\n\nint main() {\n    cout << getSum(1, 2) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 12,
    "title": "Number of 1 Bits",
    "slug": "number-of-1-bits",
    "difficulty": "Easy",
    "category": "Binary",
    "description": "Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).",
    "examples": [
      { "input": "n = 11", "output": "3", "explanation": "The binary representation of 11 is 1011, which has three set bits." },
      { "input": "n = 128", "output": "1", "explanation": "The binary representation of 128 is 10000000, which has one set bit." },
      { "input": "n = 2147483645", "output": "30" }
    ],
    "keywords": ["binary", "bit manipulation", "hamming weight", "count bits", "popcount"],
    "hints": [
      "Check each bit of the number one at a time using bitwise AND with 1.",
      "A trick: n & (n - 1) clears the lowest set bit. Count how many times you can do this.",
      "Each iteration of n = n & (n - 1) removes one set bit. Count iterations until n becomes 0."
    ],
    "scaffolds": {
      "python": "def hammingWeight(n):\n    # Return the number of 1 bits\n    pass\n\n# Example usage:\nprint(hammingWeight(11))",
      "javascript": "function hammingWeight(n) {\n  // Return the number of 1 bits\n}\n\n// Example usage:\nconsole.log(hammingWeight(11));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc hammingWeight(n uint32) int {\n\t// Return the number of 1 bits\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(hammingWeight(11))\n}",
      "java": "public class Solution {\n    public static int hammingWeight(int n) {\n        // Return the number of 1 bits\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(hammingWeight(11));\n    }\n}",
      "rust": "fn hamming_weight(n: u32) -> i32 {\n    // Return the number of 1 bits\n    0\n}\n\nfn main() {\n    println!(\"{}\", hamming_weight(11));\n}",
      "c": "#include <stdio.h>\n\nint hammingWeight(unsigned int n) {\n    // Return the number of 1 bits\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", hammingWeight(11));\n    return 0;\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nint hammingWeight(uint32_t n) {\n    // Return the number of 1 bits\n    return 0;\n}\n\nint main() {\n    cout << hammingWeight(11) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 13,
    "title": "Counting Bits",
    "slug": "counting-bits",
    "difficulty": "Easy",
    "category": "Binary",
    "description": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of `1`'s in the binary representation of `i`.",
    "examples": [
      { "input": "n = 2", "output": "[0,1,1]", "explanation": "0 --> 0, 1 --> 1, 2 --> 10" },
      { "input": "n = 5", "output": "[0,1,1,2,1,2]", "explanation": "0-->0, 1-->1, 2-->10, 3-->11, 4-->100, 5-->101" }
    ],
    "keywords": ["binary", "bit manipulation", "dynamic programming", "count bits"],
    "hints": [
      "You could count bits for each number individually, but can you use previously computed results?",
      "Key insight: bits(i) = bits(i >> 1) + (i & 1). The number of bits in i equals the bits in i/2 plus the last bit.",
      "Build the answer array from 0 to n using the recurrence. This gives O(n) time."
    ],
    "scaffolds": {
      "python": "def countBits(n):\n    # Return array of bit counts from 0 to n\n    pass\n\n# Example usage:\nprint(countBits(5))",
      "javascript": "function countBits(n) {\n  // Return array of bit counts from 0 to n\n}\n\n// Example usage:\nconsole.log(countBits(5));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc countBits(n int) []int {\n\t// Return array of bit counts from 0 to n\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(countBits(5))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[] countBits(int n) {\n        // Return array of bit counts from 0 to n\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(countBits(5)));\n    }\n}",
      "rust": "fn count_bits(n: i32) -> Vec<i32> {\n    // Return array of bit counts from 0 to n\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", count_bits(5));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* countBits(int n, int* returnSize) {\n    // Return array of bit counts from 0 to n\n    *returnSize = n + 1;\n    int* ans = (int*)calloc(n + 1, sizeof(int));\n    return ans;\n}\n\nint main() {\n    int size;\n    int* res = countBits(5, &size);\n    for (int i = 0; i < size; i++) printf(\"%d \", res[i]);\n    free(res);\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    // Return array of bit counts from 0 to n\n    return {};\n}\n\nint main() {\n    auto res = countBits(5);\n    for (int x : res) cout << x << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 14,
    "title": "Missing Number",
    "slug": "missing-number",
    "difficulty": "Easy",
    "category": "Binary",
    "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
    "examples": [
      { "input": "nums = [3,0,1]", "output": "2", "explanation": "n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is missing." },
      { "input": "nums = [0,1]", "output": "2" },
      { "input": "nums = [9,6,4,2,3,5,7,0,1]", "output": "8" }
    ],
    "keywords": ["binary", "bit manipulation", "xor", "math", "sum", "missing"],
    "hints": [
      "You could sort and scan, or use a hash set. But can you do it in O(1) space?",
      "XOR approach: XOR all numbers 0..n with all numbers in the array. Pairs cancel out, leaving the missing number.",
      "Math approach: sum(0..n) - sum(nums) = missing number. Use n*(n+1)/2 for the expected sum."
    ],
    "scaffolds": {
      "python": "def missingNumber(nums):\n    # Return the missing number from range [0, n]\n    pass\n\n# Example usage:\nprint(missingNumber([3, 0, 1]))",
      "javascript": "function missingNumber(nums) {\n  // Return the missing number from range [0, n]\n}\n\n// Example usage:\nconsole.log(missingNumber([3, 0, 1]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc missingNumber(nums []int) int {\n\t// Return the missing number from range [0, n]\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(missingNumber([]int{3, 0, 1}))\n}",
      "java": "public class Solution {\n    public static int missingNumber(int[] nums) {\n        // Return the missing number from range [0, n]\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(missingNumber(new int[]{3, 0, 1}));\n    }\n}",
      "rust": "fn missing_number(nums: Vec<i32>) -> i32 {\n    // Return the missing number from range [0, n]\n    0\n}\n\nfn main() {\n    println!(\"{}\", missing_number(vec![3, 0, 1]));\n}",
      "c": "#include <stdio.h>\n\nint missingNumber(int* nums, int numsSize) {\n    // Return the missing number from range [0, n]\n    return 0;\n}\n\nint main() {\n    int nums[] = {3, 0, 1};\n    printf(\"%d\\n\", missingNumber(nums, 3));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint missingNumber(vector<int>& nums) {\n    // Return the missing number from range [0, n]\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {3, 0, 1};\n    cout << missingNumber(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 15,
    "title": "Reverse Bits",
    "slug": "reverse-bits",
    "difficulty": "Easy",
    "category": "Binary",
    "description": "Reverse bits of a given 32 bits unsigned integer.\n\nNote that in some languages, there is no unsigned integer type. The input will be given as a signed integer, but the internal binary representation is the same whether it is signed or unsigned.",
    "examples": [
      { "input": "n = 00000010100101000001111010011100", "output": "964176192", "explanation": "The input represents 43261596. Reversing the bits gives 00111001011110000010100101000000 = 964176192." },
      { "input": "n = 11111111111111111111111111111101", "output": "3221225471" }
    ],
    "keywords": ["binary", "bit manipulation", "reverse", "32-bit", "shift"],
    "hints": [
      "Process each bit from right to left, placing it in the reversed position.",
      "Extract the last bit with n & 1, shift result left and OR the bit in. Then shift n right.",
      "Repeat 32 times to handle all bits of the 32-bit integer."
    ],
    "scaffolds": {
      "python": "def reverseBits(n):\n    # Reverse bits of a 32-bit unsigned integer\n    pass\n\n# Example usage:\nprint(reverseBits(43261596))",
      "javascript": "function reverseBits(n) {\n  // Reverse bits of a 32-bit unsigned integer\n}\n\n// Example usage:\nconsole.log(reverseBits(43261596));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc reverseBits(num uint32) uint32 {\n\t// Reverse bits of a 32-bit unsigned integer\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(reverseBits(43261596))\n}",
      "java": "public class Solution {\n    public static int reverseBits(int n) {\n        // Reverse bits of a 32-bit unsigned integer\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(reverseBits(43261596));\n    }\n}",
      "rust": "fn reverse_bits(n: u32) -> u32 {\n    // Reverse bits of a 32-bit unsigned integer\n    0\n}\n\nfn main() {\n    println!(\"{}\", reverse_bits(43261596));\n}",
      "c": "#include <stdio.h>\n#include <stdint.h>\n\nuint32_t reverseBits(uint32_t n) {\n    // Reverse bits of a 32-bit unsigned integer\n    return 0;\n}\n\nint main() {\n    printf(\"%u\\n\", reverseBits(43261596));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <cstdint>\nusing namespace std;\n\nuint32_t reverseBits(uint32_t n) {\n    // Reverse bits of a 32-bit unsigned integer\n    return 0;\n}\n\nint main() {\n    cout << reverseBits(43261596) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 16,
    "title": "Climbing Stairs",
    "slug": "climbing-stairs",
    "difficulty": "Easy",
    "category": "Dynamic Programming",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      { "input": "n = 2", "output": "2", "explanation": "There are two ways to climb to the top: 1+1 or 2." },
      { "input": "n = 3", "output": "3", "explanation": "There are three ways: 1+1+1, 1+2, and 2+1." }
    ],
    "keywords": ["dynamic programming", "fibonacci", "memoization", "recursion", "stairs"],
    "hints": [
      "Think about the relationship between the number of ways to reach step n and the steps before it.",
      "To reach step n, you can come from step n-1 (one step) or step n-2 (two steps). So ways(n) = ways(n-1) + ways(n-2).",
      "This is the Fibonacci sequence! You can solve it iteratively with O(1) space using two variables."
    ],
    "scaffolds": {
      "python": "def climbStairs(n):\n    # Return the number of distinct ways to climb n stairs\n    pass\n\n# Example usage:\nprint(climbStairs(5))",
      "javascript": "function climbStairs(n) {\n  // Return the number of distinct ways to climb n stairs\n}\n\n// Example usage:\nconsole.log(climbStairs(5));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc climbStairs(n int) int {\n\t// Return the number of distinct ways to climb n stairs\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(climbStairs(5))\n}",
      "java": "public class Solution {\n    public static int climbStairs(int n) {\n        // Return the number of distinct ways to climb n stairs\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(climbStairs(5));\n    }\n}",
      "rust": "fn climb_stairs(n: i32) -> i32 {\n    // Return the number of distinct ways to climb n stairs\n    0\n}\n\nfn main() {\n    println!(\"{}\", climb_stairs(5));\n}",
      "c": "#include <stdio.h>\n\nint climbStairs(int n) {\n    // Return the number of distinct ways to climb n stairs\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", climbStairs(5));\n    return 0;\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nint climbStairs(int n) {\n    // Return the number of distinct ways to climb n stairs\n    return 0;\n}\n\nint main() {\n    cout << climbStairs(5) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 17,
    "title": "Coin Change",
    "slug": "coin-change",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "examples": [
      { "input": "coins = [1,5,10], amount = 12", "output": "3", "explanation": "12 = 10 + 1 + 1" },
      { "input": "coins = [2], amount = 3", "output": "-1" },
      { "input": "coins = [1], amount = 0", "output": "0" }
    ],
    "keywords": ["dynamic programming", "coin", "change", "bottom-up", "bfs", "greedy"],
    "hints": [
      "Define dp[i] = minimum coins needed to make amount i. What is dp[0]?",
      "For each amount i, try every coin c: dp[i] = min(dp[i], dp[i - c] + 1) if i - c >= 0.",
      "Initialize dp array with amount + 1 (impossible value). If dp[amount] is still impossible, return -1."
    ],
    "scaffolds": {
      "python": "def coinChange(coins, amount):\n    # Return fewest coins to make amount, or -1 if impossible\n    pass\n\n# Example usage:\nprint(coinChange([1, 5, 10], 12))",
      "javascript": "function coinChange(coins, amount) {\n  // Return fewest coins to make amount, or -1 if impossible\n}\n\n// Example usage:\nconsole.log(coinChange([1, 5, 10], 12));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc coinChange(coins []int, amount int) int {\n\t// Return fewest coins to make amount, or -1 if impossible\n\treturn -1\n}\n\nfunc main() {\n\tfmt.Println(coinChange([]int{1, 5, 10}, 12))\n}",
      "java": "public class Solution {\n    public static int coinChange(int[] coins, int amount) {\n        // Return fewest coins to make amount, or -1 if impossible\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(coinChange(new int[]{1, 5, 10}, 12));\n    }\n}",
      "rust": "fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n    // Return fewest coins to make amount, or -1 if impossible\n    -1\n}\n\nfn main() {\n    println!(\"{}\", coin_change(vec![1, 5, 10], 12));\n}",
      "c": "#include <stdio.h>\n#include <limits.h>\n\nint coinChange(int* coins, int coinsSize, int amount) {\n    // Return fewest coins to make amount, or -1 if impossible\n    return -1;\n}\n\nint main() {\n    int coins[] = {1, 5, 10};\n    printf(\"%d\\n\", coinChange(coins, 3, 12));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint coinChange(vector<int>& coins, int amount) {\n    // Return fewest coins to make amount, or -1 if impossible\n    return -1;\n}\n\nint main() {\n    vector<int> coins = {1, 5, 10};\n    cout << coinChange(coins, 12) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 18,
    "title": "Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
    "examples": [
      { "input": "nums = [10,9,2,5,3,7,101,18]", "output": "4", "explanation": "The longest increasing subsequence is [2,3,7,101], length 4." },
      { "input": "nums = [0,1,0,3,2,3]", "output": "4" },
      { "input": "nums = [7,7,7,7,7,7,7]", "output": "1" }
    ],
    "keywords": ["dynamic programming", "subsequence", "increasing", "binary search", "patience sorting"],
    "hints": [
      "Define dp[i] = length of LIS ending at index i. For each i, check all j < i where nums[j] < nums[i].",
      "dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]. Answer is max(dp).",
      "For O(n log n): maintain a tails array. Use binary search to find where each element fits."
    ],
    "scaffolds": {
      "python": "def lengthOfLIS(nums):\n    # Return the length of the longest increasing subsequence\n    pass\n\n# Example usage:\nprint(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))",
      "javascript": "function lengthOfLIS(nums) {\n  // Return the length of the longest increasing subsequence\n}\n\n// Example usage:\nconsole.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc lengthOfLIS(nums []int) int {\n\t// Return the length of the longest increasing subsequence\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(lengthOfLIS([]int{10, 9, 2, 5, 3, 7, 101, 18}))\n}",
      "java": "public class Solution {\n    public static int lengthOfLIS(int[] nums) {\n        // Return the length of the longest increasing subsequence\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(lengthOfLIS(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));\n    }\n}",
      "rust": "fn length_of_lis(nums: Vec<i32>) -> i32 {\n    // Return the length of the longest increasing subsequence\n    0\n}\n\nfn main() {\n    println!(\"{}\", length_of_lis(vec![10, 9, 2, 5, 3, 7, 101, 18]));\n}",
      "c": "#include <stdio.h>\n\nint lengthOfLIS(int* nums, int numsSize) {\n    // Return the length of the longest increasing subsequence\n    return 0;\n}\n\nint main() {\n    int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};\n    printf(\"%d\\n\", lengthOfLIS(nums, 8));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint lengthOfLIS(vector<int>& nums) {\n    // Return the length of the longest increasing subsequence\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};\n    cout << lengthOfLIS(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 19,
    "title": "Longest Common Subsequence",
    "slug": "longest-common-subsequence",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
    "examples": [
      { "input": "text1 = \"abcde\", text2 = \"ace\"", "output": "3", "explanation": "The longest common subsequence is \"ace\" and its length is 3." },
      { "input": "text1 = \"abc\", text2 = \"abc\"", "output": "3" },
      { "input": "text1 = \"abc\", text2 = \"def\"", "output": "0" }
    ],
    "keywords": ["dynamic programming", "string", "subsequence", "2d dp", "lcs"],
    "hints": [
      "Use a 2D DP table where dp[i][j] = LCS length of text1[0..i-1] and text2[0..j-1].",
      "If text1[i-1] == text2[j-1], dp[i][j] = dp[i-1][j-1] + 1. Otherwise, dp[i][j] = max(dp[i-1][j], dp[i][j-1]).",
      "Build the table bottom-up. The answer is dp[m][n] where m and n are the string lengths."
    ],
    "scaffolds": {
      "python": "def longestCommonSubsequence(text1, text2):\n    # Return the length of the longest common subsequence\n    pass\n\n# Example usage:\nprint(longestCommonSubsequence(\"abcde\", \"ace\"))",
      "javascript": "function longestCommonSubsequence(text1, text2) {\n  // Return the length of the longest common subsequence\n}\n\n// Example usage:\nconsole.log(longestCommonSubsequence(\"abcde\", \"ace\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc longestCommonSubsequence(text1 string, text2 string) int {\n\t// Return the length of the longest common subsequence\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(longestCommonSubsequence(\"abcde\", \"ace\"))\n}",
      "java": "public class Solution {\n    public static int longestCommonSubsequence(String text1, String text2) {\n        // Return the length of the longest common subsequence\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(longestCommonSubsequence(\"abcde\", \"ace\"));\n    }\n}",
      "rust": "fn longest_common_subsequence(text1: String, text2: String) -> i32 {\n    // Return the length of the longest common subsequence\n    0\n}\n\nfn main() {\n    println!(\"{}\", longest_common_subsequence(\"abcde\".into(), \"ace\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint longestCommonSubsequence(char* text1, char* text2) {\n    // Return the length of the longest common subsequence\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", longestCommonSubsequence(\"abcde\", \"ace\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint longestCommonSubsequence(string text1, string text2) {\n    // Return the length of the longest common subsequence\n    return 0;\n}\n\nint main() {\n    cout << longestCommonSubsequence(\"abcde\", \"ace\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 20,
    "title": "Word Break",
    "slug": "word-break",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
    "examples": [
      { "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]", "output": "true", "explanation": "\"leetcode\" can be segmented as \"leet code\"." },
      { "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]", "output": "true" },
      { "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]", "output": "false" }
    ],
    "keywords": ["dynamic programming", "string", "word break", "dictionary", "trie", "bfs"],
    "hints": [
      "Define dp[i] = true if s[0..i-1] can be segmented using the dictionary.",
      "For each position i, check all positions j < i: if dp[j] is true and s[j..i] is in the dictionary, then dp[i] = true.",
      "Use a set for O(1) dictionary lookups. dp[0] = true (empty string). Answer is dp[n]."
    ],
    "scaffolds": {
      "python": "def wordBreak(s, wordDict):\n    # Return True if s can be segmented into dictionary words\n    pass\n\n# Example usage:\nprint(wordBreak(\"leetcode\", [\"leet\", \"code\"]))",
      "javascript": "function wordBreak(s, wordDict) {\n  // Return true if s can be segmented into dictionary words\n}\n\n// Example usage:\nconsole.log(wordBreak(\"leetcode\", [\"leet\", \"code\"]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc wordBreak(s string, wordDict []string) bool {\n\t// Return true if s can be segmented into dictionary words\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(wordBreak(\"leetcode\", []string{\"leet\", \"code\"}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean wordBreak(String s, List<String> wordDict) {\n        // Return true if s can be segmented into dictionary words\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(wordBreak(\"leetcode\", Arrays.asList(\"leet\", \"code\")));\n    }\n}",
      "rust": "use std::collections::HashSet;\n\nfn word_break(s: String, word_dict: Vec<String>) -> bool {\n    // Return true if s can be segmented into dictionary words\n    false\n}\n\nfn main() {\n    println!(\"{}\", word_break(\"leetcode\".into(), vec![\"leet\".into(), \"code\".into()]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    // Return true if s can be segmented into dictionary words\n    return false;\n}\n\nint main() {\n    char* dict[] = {\"leet\", \"code\"};\n    printf(\"%s\\n\", wordBreak(\"leetcode\", dict, 2) ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool wordBreak(string s, vector<string>& wordDict) {\n    // Return true if s can be segmented into dictionary words\n    return false;\n}\n\nint main() {\n    vector<string> dict = {\"leet\", \"code\"};\n    cout << boolalpha << wordBreak(\"leetcode\", dict) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 21,
    "title": "Combination Sum IV",
    "slug": "combination-sum-iv",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "Given an array of distinct integers `nums` and a target integer `target`, return the number of possible combinations that add up to `target`.\n\nThe answer is guaranteed to fit in a 32-bit integer.\n\nDifferent sequences are counted as different combinations (order matters).",
    "examples": [
      { "input": "nums = [1,2,3], target = 4", "output": "7", "explanation": "The possible combinations are: (1,1,1,1), (1,1,2), (1,2,1), (1,3), (2,1,1), (2,2), (3,1)." },
      { "input": "nums = [9], target = 3", "output": "0" }
    ],
    "keywords": ["dynamic programming", "combination", "sum", "permutation", "bottom-up"],
    "hints": [
      "This is similar to coin change but counting permutations, not combinations.",
      "dp[i] = number of ways to reach sum i. For each target value, try all nums as the last element.",
      "dp[0] = 1. For i from 1 to target: dp[i] = sum of dp[i - num] for each num in nums where i - num >= 0."
    ],
    "scaffolds": {
      "python": "def combinationSum4(nums, target):\n    # Return the number of combinations that add up to target\n    pass\n\n# Example usage:\nprint(combinationSum4([1, 2, 3], 4))",
      "javascript": "function combinationSum4(nums, target) {\n  // Return the number of combinations that add up to target\n}\n\n// Example usage:\nconsole.log(combinationSum4([1, 2, 3], 4));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc combinationSum4(nums []int, target int) int {\n\t// Return the number of combinations that add up to target\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(combinationSum4([]int{1, 2, 3}, 4))\n}",
      "java": "public class Solution {\n    public static int combinationSum4(int[] nums, int target) {\n        // Return the number of combinations that add up to target\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(combinationSum4(new int[]{1, 2, 3}, 4));\n    }\n}",
      "rust": "fn combination_sum4(nums: Vec<i32>, target: i32) -> i32 {\n    // Return the number of combinations that add up to target\n    0\n}\n\nfn main() {\n    println!(\"{}\", combination_sum4(vec![1, 2, 3], 4));\n}",
      "c": "#include <stdio.h>\n\nint combinationSum4(int* nums, int numsSize, int target) {\n    // Return the number of combinations that add up to target\n    return 0;\n}\n\nint main() {\n    int nums[] = {1, 2, 3};\n    printf(\"%d\\n\", combinationSum4(nums, 3, 4));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint combinationSum4(vector<int>& nums, int target) {\n    // Return the number of combinations that add up to target\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3};\n    cout << combinationSum4(nums, 4) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 22,
    "title": "House Robber",
    "slug": "house-robber",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses are arranged in a line, and adjacent houses have security systems connected — if two adjacent houses are broken into on the same night, the police will be alerted.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      { "input": "nums = [1,2,3,1]", "output": "4", "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4." },
      { "input": "nums = [2,7,9,3,1]", "output": "12", "explanation": "Rob house 1 (2), house 3 (9), and house 5 (1). Total = 12." }
    ],
    "keywords": ["dynamic programming", "greedy", "house robber", "adjacent", "max sum"],
    "hints": [
      "At each house, you have two choices: rob it or skip it.",
      "If you rob house i, you can't rob house i-1. So dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
      "You only need two variables (prev1, prev2) instead of a full array — O(1) space."
    ],
    "scaffolds": {
      "python": "def rob(nums):\n    # Return the maximum amount you can rob without alerting police\n    pass\n\n# Example usage:\nprint(rob([2, 7, 9, 3, 1]))",
      "javascript": "function rob(nums) {\n  // Return the maximum amount you can rob without alerting police\n}\n\n// Example usage:\nconsole.log(rob([2, 7, 9, 3, 1]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc rob(nums []int) int {\n\t// Return the maximum amount you can rob without alerting police\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(rob([]int{2, 7, 9, 3, 1}))\n}",
      "java": "public class Solution {\n    public static int rob(int[] nums) {\n        // Return the maximum amount you can rob without alerting police\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rob(new int[]{2, 7, 9, 3, 1}));\n    }\n}",
      "rust": "fn rob(nums: Vec<i32>) -> i32 {\n    // Return the maximum amount you can rob without alerting police\n    0\n}\n\nfn main() {\n    println!(\"{}\", rob(vec![2, 7, 9, 3, 1]));\n}",
      "c": "#include <stdio.h>\n\nint rob(int* nums, int numsSize) {\n    // Return the maximum amount you can rob without alerting police\n    return 0;\n}\n\nint main() {\n    int nums[] = {2, 7, 9, 3, 1};\n    printf(\"%d\\n\", rob(nums, 5));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint rob(vector<int>& nums) {\n    // Return the maximum amount you can rob without alerting police\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {2, 7, 9, 3, 1};\n    cout << rob(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 23,
    "title": "House Robber II",
    "slug": "house-robber-ii",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      { "input": "nums = [2,3,2]", "output": "3", "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent." },
      { "input": "nums = [1,2,3,1]", "output": "4" },
      { "input": "nums = [1,2,3]", "output": "3" }
    ],
    "keywords": ["dynamic programming", "circular", "house robber", "adjacent", "max sum"],
    "hints": [
      "Since houses are in a circle, you can't rob both the first and last house.",
      "Run the House Robber I algorithm twice: once on nums[0..n-2] and once on nums[1..n-1].",
      "Return the maximum of the two results."
    ],
    "scaffolds": {
      "python": "def rob(nums):\n    # Return the maximum amount you can rob in a circular arrangement\n    pass\n\n# Example usage:\nprint(rob([2, 3, 2]))",
      "javascript": "function rob(nums) {\n  // Return the maximum amount you can rob in a circular arrangement\n}\n\n// Example usage:\nconsole.log(rob([2, 3, 2]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc rob(nums []int) int {\n\t// Return the maximum amount you can rob in a circular arrangement\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(rob([]int{2, 3, 2}))\n}",
      "java": "public class Solution {\n    public static int rob(int[] nums) {\n        // Return the maximum amount you can rob in a circular arrangement\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rob(new int[]{2, 3, 2}));\n    }\n}",
      "rust": "fn rob(nums: Vec<i32>) -> i32 {\n    // Return the maximum amount you can rob in a circular arrangement\n    0\n}\n\nfn main() {\n    println!(\"{}\", rob(vec![2, 3, 2]));\n}",
      "c": "#include <stdio.h>\n\nint rob(int* nums, int numsSize) {\n    // Return the maximum amount you can rob in a circular arrangement\n    return 0;\n}\n\nint main() {\n    int nums[] = {2, 3, 2};\n    printf(\"%d\\n\", rob(nums, 3));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint rob(vector<int>& nums) {\n    // Return the maximum amount you can rob in a circular arrangement\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {2, 3, 2};\n    cout << rob(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 24,
    "title": "Decode Ways",
    "slug": "decode-ways",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "A message containing letters from `A-Z` can be encoded into numbers using the mapping: `'A' -> \"1\"`, `'B' -> \"2\"`, ..., `'Z' -> \"26\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.",
    "examples": [
      { "input": "s = \"12\"", "output": "2", "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)." },
      { "input": "s = \"226\"", "output": "3", "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)." },
      { "input": "s = \"06\"", "output": "0", "explanation": "\"06\" cannot be mapped because leading zeros are invalid." }
    ],
    "keywords": ["dynamic programming", "string", "decode", "fibonacci-like", "digit"],
    "hints": [
      "dp[i] = number of ways to decode s[0..i-1]. Consider taking one digit or two digits at a time.",
      "One digit: if s[i-1] != '0', dp[i] += dp[i-1]. Two digits: if s[i-2..i-1] is between 10 and 26, dp[i] += dp[i-2].",
      "Handle edge cases: leading zeros make a string undecodable. '0' alone is invalid."
    ],
    "scaffolds": {
      "python": "def numDecodings(s):\n    # Return the number of ways to decode the string\n    pass\n\n# Example usage:\nprint(numDecodings(\"226\"))",
      "javascript": "function numDecodings(s) {\n  // Return the number of ways to decode the string\n}\n\n// Example usage:\nconsole.log(numDecodings(\"226\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc numDecodings(s string) int {\n\t// Return the number of ways to decode the string\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(numDecodings(\"226\"))\n}",
      "java": "public class Solution {\n    public static int numDecodings(String s) {\n        // Return the number of ways to decode the string\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(numDecodings(\"226\"));\n    }\n}",
      "rust": "fn num_decodings(s: String) -> i32 {\n    // Return the number of ways to decode the string\n    0\n}\n\nfn main() {\n    println!(\"{}\", num_decodings(\"226\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint numDecodings(char* s) {\n    // Return the number of ways to decode the string\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", numDecodings(\"226\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint numDecodings(string s) {\n    // Return the number of ways to decode the string\n    return 0;\n}\n\nint main() {\n    cout << numDecodings(\"226\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 25,
    "title": "Unique Paths",
    "slug": "unique-paths",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner. The robot tries to move to the bottom-right corner. The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
    "examples": [
      { "input": "m = 3, n = 7", "output": "28" },
      { "input": "m = 3, n = 2", "output": "3", "explanation": "From the top-left corner, there are 3 ways: Right->Down->Down, Down->Down->Right, Down->Right->Down." }
    ],
    "keywords": ["dynamic programming", "grid", "path", "combinatorics", "2d dp"],
    "hints": [
      "dp[i][j] = number of unique paths to reach cell (i, j). The first row and first column are all 1s.",
      "dp[i][j] = dp[i-1][j] + dp[i][j-1] — you can arrive from above or from the left.",
      "You can optimize to O(n) space by using a single row and updating it in place."
    ],
    "scaffolds": {
      "python": "def uniquePaths(m, n):\n    # Return the number of unique paths in an m x n grid\n    pass\n\n# Example usage:\nprint(uniquePaths(3, 7))",
      "javascript": "function uniquePaths(m, n) {\n  // Return the number of unique paths in an m x n grid\n}\n\n// Example usage:\nconsole.log(uniquePaths(3, 7));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc uniquePaths(m int, n int) int {\n\t// Return the number of unique paths in an m x n grid\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(uniquePaths(3, 7))\n}",
      "java": "public class Solution {\n    public static int uniquePaths(int m, int n) {\n        // Return the number of unique paths in an m x n grid\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(uniquePaths(3, 7));\n    }\n}",
      "rust": "fn unique_paths(m: i32, n: i32) -> i32 {\n    // Return the number of unique paths in an m x n grid\n    0\n}\n\nfn main() {\n    println!(\"{}\", unique_paths(3, 7));\n}",
      "c": "#include <stdio.h>\n\nint uniquePaths(int m, int n) {\n    // Return the number of unique paths in an m x n grid\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", uniquePaths(3, 7));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    // Return the number of unique paths in an m x n grid\n    return 0;\n}\n\nint main() {\n    cout << uniquePaths(3, 7) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 26,
    "title": "Jump Game",
    "slug": "jump-game",
    "difficulty": "Medium",
    "category": "Dynamic Programming",
    "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
    "examples": [
      { "input": "nums = [2,3,1,1,4]", "output": "true", "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index." },
      { "input": "nums = [3,2,1,0,4]", "output": "false", "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, making it impossible to reach the last index." }
    ],
    "keywords": ["dynamic programming", "greedy", "jump", "reachability"],
    "hints": [
      "Greedy approach: track the farthest index you can reach as you iterate.",
      "At each index i, if i > farthest, you can't reach this position — return false.",
      "Update farthest = max(farthest, i + nums[i]). If farthest >= last index, return true."
    ],
    "scaffolds": {
      "python": "def canJump(nums):\n    # Return True if you can reach the last index\n    pass\n\n# Example usage:\nprint(canJump([2, 3, 1, 1, 4]))",
      "javascript": "function canJump(nums) {\n  // Return true if you can reach the last index\n}\n\n// Example usage:\nconsole.log(canJump([2, 3, 1, 1, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc canJump(nums []int) bool {\n\t// Return true if you can reach the last index\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(canJump([]int{2, 3, 1, 1, 4}))\n}",
      "java": "public class Solution {\n    public static boolean canJump(int[] nums) {\n        // Return true if you can reach the last index\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(canJump(new int[]{2, 3, 1, 1, 4}));\n    }\n}",
      "rust": "fn can_jump(nums: Vec<i32>) -> bool {\n    // Return true if you can reach the last index\n    false\n}\n\nfn main() {\n    println!(\"{}\", can_jump(vec![2, 3, 1, 1, 4]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canJump(int* nums, int numsSize) {\n    // Return true if you can reach the last index\n    return false;\n}\n\nint main() {\n    int nums[] = {2, 3, 1, 1, 4};\n    printf(\"%s\\n\", canJump(nums, 5) ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canJump(vector<int>& nums) {\n    // Return true if you can reach the last index\n    return false;\n}\n\nint main() {\n    vector<int> nums = {2, 3, 1, 1, 4};\n    cout << boolalpha << canJump(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 27,
    "title": "Clone Graph",
    "slug": "clone-graph",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list of its neighbors (`List[Node]`).",
    "examples": [
      { "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]", "output": "[[2,4],[1,3],[2,4],[1,3]]", "explanation": "The graph has 4 nodes. Node 1's neighbors are 2 and 4. The clone should be a deep copy." },
      { "input": "adjList = [[]]", "output": "[[]]" }
    ],
    "keywords": ["graph", "bfs", "dfs", "clone", "hash map", "deep copy"],
    "hints": [
      "Use a hash map to track which nodes have already been cloned (original -> clone).",
      "BFS or DFS: for each node, create its clone if not already created, then recursively clone its neighbors.",
      "The hash map serves double duty: it prevents infinite loops in cyclic graphs and maps originals to clones."
    ],
    "scaffolds": {
      "python": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors else []\n\ndef cloneGraph(node):\n    # Return a deep copy of the graph\n    pass",
      "javascript": "function Node(val, neighbors) {\n  this.val = val === undefined ? 0 : val;\n  this.neighbors = neighbors === undefined ? [] : neighbors;\n}\n\nfunction cloneGraph(node) {\n  // Return a deep copy of the graph\n}",
      "go": "package main\n\ntype Node struct {\n\tVal       int\n\tNeighbors []*Node\n}\n\nfunc cloneGraph(node *Node) *Node {\n\t// Return a deep copy of the graph\n\treturn nil\n}\n\nfunc main() {}",
      "java": "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node(int val) { this.val = val; this.neighbors = new ArrayList<>(); }\n}\n\npublic class Solution {\n    public static Node cloneGraph(Node node) {\n        // Return a deep copy of the graph\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::collections::HashMap;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    val: i32,\n    neighbors: Vec<Rc<RefCell<Node>>>,\n}\n\nfn clone_graph(node: Option<Rc<RefCell<Node>>>) -> Option<Rc<RefCell<Node>>> {\n    // Return a deep copy of the graph\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int val;\n    int numNeighbors;\n    struct Node** neighbors;\n};\n\nstruct Node* cloneGraph(struct Node* s) {\n    // Return a deep copy of the graph\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node(int _val) : val(_val) {}\n};\n\nNode* cloneGraph(Node* node) {\n    // Return a deep copy of the graph\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 28,
    "title": "Course Schedule",
    "slug": "course-schedule",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you must take course `b_i` first if you want to take course `a_i`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
    "examples": [
      { "input": "numCourses = 2, prerequisites = [[1,0]]", "output": "true", "explanation": "Take course 0 first, then course 1." },
      { "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]", "output": "false", "explanation": "There is a cycle: course 0 requires 1 and course 1 requires 0." }
    ],
    "keywords": ["graph", "topological sort", "cycle detection", "bfs", "dfs", "directed graph"],
    "hints": [
      "This is a cycle detection problem in a directed graph. If there's a cycle, you can't finish all courses.",
      "BFS (Kahn's algorithm): start with nodes that have 0 in-degree. Process them, reducing neighbors' in-degree.",
      "If you process all nodes, there's no cycle. If some remain, a cycle exists."
    ],
    "scaffolds": {
      "python": "def canFinish(numCourses, prerequisites):\n    # Return True if all courses can be finished\n    pass\n\n# Example usage:\nprint(canFinish(2, [[1, 0]]))",
      "javascript": "function canFinish(numCourses, prerequisites) {\n  // Return true if all courses can be finished\n}\n\n// Example usage:\nconsole.log(canFinish(2, [[1, 0]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n\t// Return true if all courses can be finished\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(canFinish(2, [][]int{{1, 0}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Return true if all courses can be finished\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(canFinish(2, new int[][]{{1, 0}}));\n    }\n}",
      "rust": "fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n    // Return true if all courses can be finished\n    false\n}\n\nfn main() {\n    println!(\"{}\", can_finish(2, vec![vec![1, 0]]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize) {\n    // Return true if all courses can be finished\n    return false;\n}\n\nint main() {\n    printf(\"false\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // Return true if all courses can be finished\n    return false;\n}\n\nint main() {\n    vector<vector<int>> prereqs = {{1, 0}};\n    cout << boolalpha << canFinish(2, prereqs) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 29,
    "title": "Pacific Atlantic Water Flow",
    "slug": "pacific-atlantic-water-flow",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "There is an `m x n` rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n\nThe island receives rain. Water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [r_i, c_i]` denotes that rain water can flow from cell `(r_i, c_i)` to both the Pacific and Atlantic oceans.",
    "examples": [
      { "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]", "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]" },
      { "input": "heights = [[1]]", "output": "[[0,0]]" }
    ],
    "keywords": ["graph", "dfs", "bfs", "matrix", "flood fill", "ocean"],
    "hints": [
      "Instead of flowing from each cell to the ocean, reverse the problem: flow from the ocean inward.",
      "Do BFS/DFS from all Pacific border cells and mark reachable cells. Do the same from Atlantic border cells.",
      "Cells that are reachable from both oceans are the answer."
    ],
    "scaffolds": {
      "python": "def pacificAtlantic(heights):\n    # Return coordinates where water can flow to both oceans\n    pass\n\n# Example usage:\nprint(pacificAtlantic([[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]))",
      "javascript": "function pacificAtlantic(heights) {\n  // Return coordinates where water can flow to both oceans\n}\n\n// Example usage:\nconsole.log(pacificAtlantic([[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc pacificAtlantic(heights [][]int) [][]int {\n\t// Return coordinates where water can flow to both oceans\n\treturn nil\n}\n\nfunc main() {\n\theights := [][]int{{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}}\n\tfmt.Println(pacificAtlantic(heights))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static List<List<Integer>> pacificAtlantic(int[][] heights) {\n        // Return coordinates where water can flow to both oceans\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        int[][] h = {{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}};\n        System.out.println(pacificAtlantic(h));\n    }\n}",
      "rust": "fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n    // Return coordinates where water can flow to both oceans\n    vec![]\n}\n\nfn main() {\n    let h = vec![vec![1,2,2,3,5],vec![3,2,3,4,4],vec![2,4,5,3,1],vec![6,7,1,4,5],vec![5,1,1,2,4]];\n    println!(\"{:?}\", pacific_atlantic(h));\n}",
      "c": "#include <stdio.h>\n\nint** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes) {\n    // Return coordinates where water can flow to both oceans\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    // Return coordinates where water can flow to both oceans\n    return {};\n}\n\nint main() {\n    vector<vector<int>> h = {{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}};\n    auto res = pacificAtlantic(h);\n    for (auto& r : res) cout << r[0] << \",\" << r[1] << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 30,
    "title": "Number of Islands",
    "slug": "number-of-islands",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
      { "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1" },
      { "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "3" }
    ],
    "keywords": ["graph", "dfs", "bfs", "matrix", "flood fill", "connected components", "union find"],
    "hints": [
      "Iterate through the grid. When you find a '1', increment the island count and sink the entire island.",
      "Use DFS or BFS to mark all connected '1's as visited (change to '0' or use a visited set).",
      "Each time you start a new DFS/BFS from an unvisited '1', that's a new island."
    ],
    "scaffolds": {
      "python": "def numIslands(grid):\n    # Return the number of islands\n    pass\n\n# Example usage:\nprint(numIslands([[\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]))",
      "javascript": "function numIslands(grid) {\n  // Return the number of islands\n}\n\n// Example usage:\nconsole.log(numIslands([[\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc numIslands(grid [][]byte) int {\n\t// Return the number of islands\n\treturn 0\n}\n\nfunc main() {\n\tgrid := [][]byte{{'1','1','0'},{'0','1','0'},{'0','0','1'}}\n\tfmt.Println(numIslands(grid))\n}",
      "java": "public class Solution {\n    public static int numIslands(char[][] grid) {\n        // Return the number of islands\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {{'1','1','0'},{'0','1','0'},{'0','0','1'}};\n        System.out.println(numIslands(grid));\n    }\n}",
      "rust": "fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n    // Return the number of islands\n    0\n}\n\nfn main() {\n    let grid = vec![vec!['1','1','0'],vec!['0','1','0'],vec!['0','0','1']];\n    println!(\"{}\", num_islands(grid));\n}",
      "c": "#include <stdio.h>\n\nint numIslands(char** grid, int gridSize, int* gridColSize) {\n    // Return the number of islands\n    return 0;\n}\n\nint main() {\n    printf(\"0\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint numIslands(vector<vector<char>>& grid) {\n    // Return the number of islands\n    return 0;\n}\n\nint main() {\n    vector<vector<char>> grid = {{'1','1','0'},{'0','1','0'},{'0','0','1'}};\n    cout << numIslands(grid) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 31,
    "title": "Longest Consecutive Sequence",
    "slug": "longest-consecutive-sequence",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.",
    "examples": [
      { "input": "nums = [100,4,200,1,3,2]", "output": "4", "explanation": "The longest consecutive sequence is [1,2,3,4]. Its length is 4." },
      { "input": "nums = [0,3,7,2,5,8,4,6,0,1]", "output": "9" }
    ],
    "keywords": ["array", "hash set", "consecutive", "sequence", "union find"],
    "hints": [
      "Put all numbers in a hash set for O(1) lookups.",
      "For each number, check if it's the start of a sequence (num - 1 is NOT in the set).",
      "If it is a start, count consecutive numbers (num+1, num+2, ...) and track the longest."
    ],
    "scaffolds": {
      "python": "def longestConsecutive(nums):\n    # Return the length of the longest consecutive sequence\n    pass\n\n# Example usage:\nprint(longestConsecutive([100, 4, 200, 1, 3, 2]))",
      "javascript": "function longestConsecutive(nums) {\n  // Return the length of the longest consecutive sequence\n}\n\n// Example usage:\nconsole.log(longestConsecutive([100, 4, 200, 1, 3, 2]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc longestConsecutive(nums []int) int {\n\t// Return the length of the longest consecutive sequence\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(longestConsecutive([]int{100, 4, 200, 1, 3, 2}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int longestConsecutive(int[] nums) {\n        // Return the length of the longest consecutive sequence\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(longestConsecutive(new int[]{100, 4, 200, 1, 3, 2}));\n    }\n}",
      "rust": "use std::collections::HashSet;\n\nfn longest_consecutive(nums: Vec<i32>) -> i32 {\n    // Return the length of the longest consecutive sequence\n    0\n}\n\nfn main() {\n    println!(\"{}\", longest_consecutive(vec![100, 4, 200, 1, 3, 2]));\n}",
      "c": "#include <stdio.h>\n\nint longestConsecutive(int* nums, int numsSize) {\n    // Return the length of the longest consecutive sequence\n    return 0;\n}\n\nint main() {\n    int nums[] = {100, 4, 200, 1, 3, 2};\n    printf(\"%d\\n\", longestConsecutive(nums, 6));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint longestConsecutive(vector<int>& nums) {\n    // Return the length of the longest consecutive sequence\n    return 0;\n}\n\nint main() {\n    vector<int> nums = {100, 4, 200, 1, 3, 2};\n    cout << longestConsecutive(nums) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 32,
    "title": "Alien Dictionary",
    "slug": "alien-dictionary",
    "difficulty": "Hard",
    "category": "Graph",
    "description": "There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings are sorted lexicographically by the rules of this new language.\n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid orderings, return any of them.",
    "examples": [
      { "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]", "output": "\"wertf\"" },
      { "input": "words = [\"z\",\"x\"]", "output": "\"zx\"" },
      { "input": "words = [\"z\",\"x\",\"z\"]", "output": "\"\"", "explanation": "The order is invalid, so return empty string." }
    ],
    "keywords": ["graph", "topological sort", "directed graph", "bfs", "alien", "ordering"],
    "hints": [
      "Compare adjacent words to extract ordering rules. The first differing character gives you an edge in the graph.",
      "Build a directed graph from these edges and perform topological sort.",
      "If a cycle is detected (not all nodes processed), the ordering is invalid — return empty string."
    ],
    "scaffolds": {
      "python": "def alienOrder(words):\n    # Return the order of letters in the alien language\n    pass\n\n# Example usage:\nprint(alienOrder([\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]))",
      "javascript": "function alienOrder(words) {\n  // Return the order of letters in the alien language\n}\n\n// Example usage:\nconsole.log(alienOrder([\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc alienOrder(words []string) string {\n\t// Return the order of letters in the alien language\n\treturn \"\"\n}\n\nfunc main() {\n\tfmt.Println(alienOrder([]string{\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static String alienOrder(String[] words) {\n        // Return the order of letters in the alien language\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(alienOrder(new String[]{\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"}));\n    }\n}",
      "rust": "use std::collections::{HashMap, HashSet, VecDeque};\n\nfn alien_order(words: Vec<String>) -> String {\n    // Return the order of letters in the alien language\n    String::new()\n}\n\nfn main() {\n    let words: Vec<String> = vec![\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"].iter().map(|s| s.to_string()).collect();\n    println!(\"{}\", alien_order(words));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nchar* alienOrder(char** words, int wordsSize) {\n    // Return the order of letters in the alien language\n    static char result[27] = \"\";\n    return result;\n}\n\nint main() {\n    char* words[] = {\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"};\n    printf(\"%s\\n\", alienOrder(words, 5));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\nstring alienOrder(vector<string>& words) {\n    // Return the order of letters in the alien language\n    return \"\";\n}\n\nint main() {\n    vector<string> words = {\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"};\n    cout << alienOrder(words) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 33,
    "title": "Graph Valid Tree",
    "slug": "graph-valid-tree",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given the integer `n` and a list of `edges` where `edges[i] = [a_i, b_i]` indicates that there is an undirected edge between nodes `a_i` and `b_i`.\n\nReturn `true` if the edges form a valid tree, and `false` otherwise.\n\nA valid tree has exactly `n - 1` edges, is connected, and has no cycles.",
    "examples": [
      { "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]", "output": "true" },
      { "input": "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]", "output": "false" }
    ],
    "keywords": ["graph", "tree", "union find", "dfs", "bfs", "cycle detection", "connected"],
    "hints": [
      "A valid tree with n nodes must have exactly n - 1 edges. Check this first.",
      "Then check if the graph is connected (all nodes reachable from node 0) using BFS/DFS.",
      "Alternatively, use Union-Find: if adding an edge connects two already-connected nodes, there's a cycle."
    ],
    "scaffolds": {
      "python": "def validTree(n, edges):\n    # Return True if the edges form a valid tree\n    pass\n\n# Example usage:\nprint(validTree(5, [[0,1],[0,2],[0,3],[1,4]]))",
      "javascript": "function validTree(n, edges) {\n  // Return true if the edges form a valid tree\n}\n\n// Example usage:\nconsole.log(validTree(5, [[0,1],[0,2],[0,3],[1,4]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc validTree(n int, edges [][]int) bool {\n\t// Return true if the edges form a valid tree\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(validTree(5, [][]int{{0,1},{0,2},{0,3},{1,4}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean validTree(int n, int[][] edges) {\n        // Return true if the edges form a valid tree\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(validTree(5, new int[][]{{0,1},{0,2},{0,3},{1,4}}));\n    }\n}",
      "rust": "fn valid_tree(n: i32, edges: Vec<Vec<i32>>) -> bool {\n    // Return true if the edges form a valid tree\n    false\n}\n\nfn main() {\n    println!(\"{}\", valid_tree(5, vec![vec![0,1],vec![0,2],vec![0,3],vec![1,4]]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nbool validTree(int n, int** edges, int edgesSize, int* edgesColSize) {\n    // Return true if the edges form a valid tree\n    return false;\n}\n\nint main() {\n    printf(\"false\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool validTree(int n, vector<vector<int>>& edges) {\n    // Return true if the edges form a valid tree\n    return false;\n}\n\nint main() {\n    vector<vector<int>> edges = {{0,1},{0,2},{0,3},{1,4}};\n    cout << boolalpha << validTree(5, edges) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 34,
    "title": "Number of Connected Components in an Undirected Graph",
    "slug": "number-of-connected-components",
    "difficulty": "Medium",
    "category": "Graph",
    "description": "You have a graph of `n` nodes. You are given the integer `n` and an array `edges` where `edges[i] = [a_i, b_i]` indicates that there is an edge between nodes `a_i` and `b_i`.\n\nReturn the number of connected components in the graph.",
    "examples": [
      { "input": "n = 5, edges = [[0,1],[1,2],[3,4]]", "output": "2" },
      { "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]", "output": "1" }
    ],
    "keywords": ["graph", "union find", "dfs", "bfs", "connected components"],
    "hints": [
      "Use Union-Find: start with n components. Each edge merges two components.",
      "Alternatively, build an adjacency list and count the number of BFS/DFS traversals needed to visit all nodes.",
      "With Union-Find, the final count of unique roots is the number of connected components."
    ],
    "scaffolds": {
      "python": "def countComponents(n, edges):\n    # Return the number of connected components\n    pass\n\n# Example usage:\nprint(countComponents(5, [[0,1],[1,2],[3,4]]))",
      "javascript": "function countComponents(n, edges) {\n  // Return the number of connected components\n}\n\n// Example usage:\nconsole.log(countComponents(5, [[0,1],[1,2],[3,4]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc countComponents(n int, edges [][]int) int {\n\t// Return the number of connected components\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(countComponents(5, [][]int{{0,1},{1,2},{3,4}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int countComponents(int n, int[][] edges) {\n        // Return the number of connected components\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countComponents(5, new int[][]{{0,1},{1,2},{3,4}}));\n    }\n}",
      "rust": "fn count_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\n    // Return the number of connected components\n    0\n}\n\nfn main() {\n    println!(\"{}\", count_components(5, vec![vec![0,1],vec![1,2],vec![3,4]]));\n}",
      "c": "#include <stdio.h>\n\nint countComponents(int n, int** edges, int edgesSize, int* edgesColSize) {\n    // Return the number of connected components\n    return 0;\n}\n\nint main() {\n    printf(\"0\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint countComponents(int n, vector<vector<int>>& edges) {\n    // Return the number of connected components\n    return 0;\n}\n\nint main() {\n    vector<vector<int>> edges = {{0,1},{1,2},{3,4}};\n    cout << countComponents(5, edges) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 35,
    "title": "Merge Intervals",
    "slug": "merge-intervals",
    "difficulty": "Medium",
    "category": "Interval",
    "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
      { "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]", "output": "[[1,6],[8,10],[15,18]]", "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]." },
      { "input": "intervals = [[1,4],[4,5]]", "output": "[[1,5]]" }
    ],
    "keywords": ["interval", "sorting", "merge", "overlapping", "greedy"],
    "hints": [
      "Start by sorting the intervals by their start value. Why does this help?",
      "After sorting, iterate through intervals. If the current interval overlaps with the last merged interval, extend it.",
      "Two intervals overlap when the current start <= the previous end. The merged end is the max of both ends."
    ],
    "scaffolds": {
      "python": "def merge(intervals):\n    # Return merged non-overlapping intervals\n    pass\n\n# Example usage:\nprint(merge([[1,3],[2,6],[8,10],[15,18]]))",
      "javascript": "function merge(intervals) {\n  // Return merged non-overlapping intervals\n}\n\n// Example usage:\nconsole.log(merge([[1,3],[2,6],[8,10],[15,18]]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc merge(intervals [][]int) [][]int {\n\t// Return merged non-overlapping intervals\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(merge([][]int{{1,3},{2,6},{8,10},{15,18}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[][] merge(int[][] intervals) {\n        // Return merged non-overlapping intervals\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        return new int[][]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.deepToString(merge(new int[][]{{1,3},{2,6},{8,10},{15,18}})));\n    }\n}",
      "rust": "fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n    // Return merged non-overlapping intervals\n    intervals.sort_by_key(|v| v[0]);\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", merge(vec![vec![1,3],vec![2,6],vec![8,10],vec![15,18]]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) {\n    return (*(int**)a)[0] - (*(int**)b)[0];\n}\n\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes) {\n    // Return merged non-overlapping intervals\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\n    // Return merged non-overlapping intervals\n    sort(intervals.begin(), intervals.end());\n    return {};\n}\n\nint main() {\n    vector<vector<int>> intervals = {{1,3},{2,6},{8,10},{15,18}};\n    auto res = merge(intervals);\n    for (auto& r : res) cout << \"[\" << r[0] << \",\" << r[1] << \"] \";\n    return 0;\n}"
    }
  },
  {
    "id": 36,
    "title": "Insert Interval",
    "slug": "insert-interval",
    "difficulty": "Medium",
    "category": "Interval",
    "description": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [start_i, end_i]` represent the start and the end of the `i`th interval and `intervals` is sorted in ascending order by `start_i`. You are also given an interval `newInterval = [start, end]`.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `start_i` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` after the insertion.",
    "examples": [
      { "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]", "output": "[[1,5],[6,9]]" },
      { "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]", "output": "[[1,2],[3,10],[12,16]]" }
    ],
    "keywords": ["interval", "merge", "insert", "sorted", "overlapping"],
    "hints": [
      "Split the problem into three parts: intervals before the new one, overlapping intervals, and intervals after.",
      "Add all intervals that end before newInterval starts. Merge all that overlap with newInterval. Add the rest.",
      "While overlapping, expand newInterval: start = min(start, interval.start), end = max(end, interval.end)."
    ],
    "scaffolds": {
      "python": "def insert(intervals, newInterval):\n    # Insert and merge the new interval\n    pass\n\n# Example usage:\nprint(insert([[1,3],[6,9]], [2,5]))",
      "javascript": "function insert(intervals, newInterval) {\n  // Insert and merge the new interval\n}\n\n// Example usage:\nconsole.log(insert([[1,3],[6,9]], [2,5]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc insert(intervals [][]int, newInterval []int) [][]int {\n\t// Insert and merge the new interval\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(insert([][]int{{1,3},{6,9}}, []int{2,5}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[][] insert(int[][] intervals, int[] newInterval) {\n        // Insert and merge the new interval\n        return new int[][]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.deepToString(insert(new int[][]{{1,3},{6,9}}, new int[]{2,5})));\n    }\n}",
      "rust": "fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n    // Insert and merge the new interval\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", insert(vec![vec![1,3],vec![6,9]], vec![2,5]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) {\n    // Insert and merge the new interval\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    // Insert and merge the new interval\n    return {};\n}\n\nint main() {\n    vector<vector<int>> intervals = {{1,3},{6,9}};\n    vector<int> ni = {2,5};\n    auto res = insert(intervals, ni);\n    for (auto& r : res) cout << \"[\" << r[0] << \",\" << r[1] << \"] \";\n    return 0;\n}"
    }
  },
  {
    "id": 37,
    "title": "Non-overlapping Intervals",
    "slug": "non-overlapping-intervals",
    "difficulty": "Medium",
    "category": "Interval",
    "description": "Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
    "examples": [
      { "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]", "output": "1", "explanation": "[1,3] can be removed and the rest are non-overlapping." },
      { "input": "intervals = [[1,2],[1,2],[1,2]]", "output": "2" },
      { "input": "intervals = [[1,2],[2,3]]", "output": "0" }
    ],
    "keywords": ["interval", "greedy", "sorting", "overlapping", "scheduling"],
    "hints": [
      "This is equivalent to finding the maximum number of non-overlapping intervals (activity selection problem).",
      "Sort intervals by end time. Greedily pick intervals that don't overlap with the last picked one.",
      "The answer is total intervals minus the maximum non-overlapping set."
    ],
    "scaffolds": {
      "python": "def eraseOverlapIntervals(intervals):\n    # Return minimum intervals to remove for non-overlapping\n    pass\n\n# Example usage:\nprint(eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]))",
      "javascript": "function eraseOverlapIntervals(intervals) {\n  // Return minimum intervals to remove for non-overlapping\n}\n\n// Example usage:\nconsole.log(eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc eraseOverlapIntervals(intervals [][]int) int {\n\t// Return minimum intervals to remove for non-overlapping\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][1] < intervals[j][1] })\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(eraseOverlapIntervals([][]int{{1,2},{2,3},{3,4},{1,3}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int eraseOverlapIntervals(int[][] intervals) {\n        // Return minimum intervals to remove for non-overlapping\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(eraseOverlapIntervals(new int[][]{{1,2},{2,3},{3,4},{1,3}}));\n    }\n}",
      "rust": "fn erase_overlap_intervals(mut intervals: Vec<Vec<i32>>) -> i32 {\n    // Return minimum intervals to remove for non-overlapping\n    intervals.sort_by_key(|v| v[1]);\n    0\n}\n\nfn main() {\n    println!(\"{}\", erase_overlap_intervals(vec![vec![1,2],vec![2,3],vec![3,4],vec![1,3]]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) { return (*(int**)a)[1] - (*(int**)b)[1]; }\n\nint eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\n    // Return minimum intervals to remove for non-overlapping\n    return 0;\n}\n\nint main() {\n    printf(\"0\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\n    // Return minimum intervals to remove for non-overlapping\n    sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){ return a[1] < b[1]; });\n    return 0;\n}\n\nint main() {\n    vector<vector<int>> intervals = {{1,2},{2,3},{3,4},{1,3}};\n    cout << eraseOverlapIntervals(intervals) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 38,
    "title": "Meeting Rooms",
    "slug": "meeting-rooms",
    "difficulty": "Easy",
    "category": "Interval",
    "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [start_i, end_i]`, determine if a person could attend all meetings.\n\nReturn `true` if there are no overlapping meetings.",
    "examples": [
      { "input": "intervals = [[0,30],[5,10],[15,20]]", "output": "false" },
      { "input": "intervals = [[7,10],[2,4]]", "output": "true" }
    ],
    "keywords": ["interval", "sorting", "overlapping", "meeting", "scheduling"],
    "hints": [
      "Sort the intervals by start time.",
      "Check if any interval starts before the previous one ends.",
      "If intervals[i].start < intervals[i-1].end, there's an overlap — return false."
    ],
    "scaffolds": {
      "python": "def canAttendMeetings(intervals):\n    # Return True if a person can attend all meetings\n    pass\n\n# Example usage:\nprint(canAttendMeetings([[0,30],[5,10],[15,20]]))",
      "javascript": "function canAttendMeetings(intervals) {\n  // Return true if a person can attend all meetings\n}\n\n// Example usage:\nconsole.log(canAttendMeetings([[0,30],[5,10],[15,20]]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc canAttendMeetings(intervals [][]int) bool {\n\t// Return true if a person can attend all meetings\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(canAttendMeetings([][]int{{0,30},{5,10},{15,20}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean canAttendMeetings(int[][] intervals) {\n        // Return true if a person can attend all meetings\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(canAttendMeetings(new int[][]{{0,30},{5,10},{15,20}}));\n    }\n}",
      "rust": "fn can_attend_meetings(mut intervals: Vec<Vec<i32>>) -> bool {\n    // Return true if a person can attend all meetings\n    intervals.sort_by_key(|v| v[0]);\n    true\n}\n\nfn main() {\n    println!(\"{}\", can_attend_meetings(vec![vec![0,30],vec![5,10],vec![15,20]]));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) { return (*(int**)a)[0] - (*(int**)b)[0]; }\n\nbool canAttendMeetings(int** intervals, int intervalsSize, int* intervalsColSize) {\n    // Return true if a person can attend all meetings\n    return true;\n}\n\nint main() {\n    printf(\"true\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canAttendMeetings(vector<vector<int>>& intervals) {\n    // Return true if a person can attend all meetings\n    sort(intervals.begin(), intervals.end());\n    return true;\n}\n\nint main() {\n    vector<vector<int>> intervals = {{0,30},{5,10},{15,20}};\n    cout << boolalpha << canAttendMeetings(intervals) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 39,
    "title": "Meeting Rooms II",
    "slug": "meeting-rooms-ii",
    "difficulty": "Medium",
    "category": "Interval",
    "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.",
    "examples": [
      { "input": "intervals = [[0,30],[5,10],[15,20]]", "output": "2" },
      { "input": "intervals = [[7,10],[2,4]]", "output": "1" }
    ],
    "keywords": ["interval", "heap", "sorting", "meeting", "sweep line", "min heap"],
    "hints": [
      "Sort meetings by start time. Use a min-heap to track end times of ongoing meetings.",
      "For each meeting, if the earliest ending meeting ends before this one starts, reuse that room (pop from heap).",
      "Push the current meeting's end time. The heap size at any point is the number of rooms in use."
    ],
    "scaffolds": {
      "python": "import heapq\n\ndef minMeetingRooms(intervals):\n    # Return the minimum number of conference rooms required\n    pass\n\n# Example usage:\nprint(minMeetingRooms([[0,30],[5,10],[15,20]]))",
      "javascript": "function minMeetingRooms(intervals) {\n  // Return the minimum number of conference rooms required\n}\n\n// Example usage:\nconsole.log(minMeetingRooms([[0,30],[5,10],[15,20]]));",
      "go": "package main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype IntHeap []int\nfunc (h IntHeap) Len() int            { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool   { return h[i] < h[j] }\nfunc (h IntHeap) Swap(i, j int)        { h[i], h[j] = h[j], h[i] }\nfunc (h *IntHeap) Push(x interface{})  { *h = append(*h, x.(int)) }\nfunc (h *IntHeap) Pop() interface{}    { old := *h; n := len(old); x := old[n-1]; *h = old[:n-1]; return x }\n\nfunc minMeetingRooms(intervals [][]int) int {\n\t// Return the minimum number of conference rooms required\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(minMeetingRooms([][]int{{0,30},{5,10},{15,20}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int minMeetingRooms(int[][] intervals) {\n        // Return the minimum number of conference rooms required\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(minMeetingRooms(new int[][]{{0,30},{5,10},{15,20}}));\n    }\n}",
      "rust": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\nfn min_meeting_rooms(mut intervals: Vec<Vec<i32>>) -> i32 {\n    // Return the minimum number of conference rooms required\n    intervals.sort_by_key(|v| v[0]);\n    0\n}\n\nfn main() {\n    println!(\"{}\", min_meeting_rooms(vec![vec![0,30],vec![5,10],vec![15,20]]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) { return (*(int**)a)[0] - (*(int**)b)[0]; }\n\nint minMeetingRooms(int** intervals, int intervalsSize, int* intervalsColSize) {\n    // Return the minimum number of conference rooms required\n    return 0;\n}\n\nint main() {\n    printf(\"0\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint minMeetingRooms(vector<vector<int>>& intervals) {\n    // Return the minimum number of conference rooms required\n    sort(intervals.begin(), intervals.end());\n    return 0;\n}\n\nint main() {\n    vector<vector<int>> intervals = {{0,30},{5,10},{15,20}};\n    cout << minMeetingRooms(intervals) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 40,
    "title": "Reverse Linked List",
    "slug": "reverse-linked-list",
    "difficulty": "Easy",
    "category": "Linked List",
    "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
    "examples": [
      { "input": "head = [1,2,3,4,5]", "output": "[5,4,3,2,1]" },
      { "input": "head = [1,2]", "output": "[2,1]" },
      { "input": "head = []", "output": "[]" }
    ],
    "keywords": ["linked list", "reverse", "iterative", "recursive", "pointers"],
    "hints": [
      "Use three pointers: prev, current, and next. At each step, reverse the current node's pointer.",
      "Save current.next, point current.next to prev, advance prev and current.",
      "When current is null, prev is the new head of the reversed list."
    ],
    "scaffolds": {
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head):\n    # Reverse the linked list and return the new head\n    pass",
      "javascript": "function ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction reverseList(head) {\n  // Reverse the linked list and return the new head\n}",
      "go": "package main\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc reverseList(head *ListNode) *ListNode {\n\t// Reverse the linked list and return the new head\n\treturn nil\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static ListNode reverseList(ListNode head) {\n        // Reverse the linked list and return the new head\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    // Reverse the linked list and return the new head\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* reverseList(struct ListNode* head) {\n    // Reverse the linked list and return the new head\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* reverseList(ListNode* head) {\n    // Reverse the linked list and return the new head\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 41,
    "title": "Linked List Cycle",
    "slug": "linked-list-cycle",
    "difficulty": "Easy",
    "category": "Linked List",
    "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.\n\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.",
    "examples": [
      { "input": "head = [3,2,0,-4], pos = 1", "output": "true", "explanation": "There is a cycle where the tail connects to the 1st node (0-indexed)." },
      { "input": "head = [1,2], pos = 0", "output": "true" },
      { "input": "head = [1], pos = -1", "output": "false" }
    ],
    "keywords": ["linked list", "cycle", "fast slow", "tortoise hare", "floyd"],
    "hints": [
      "Use two pointers: slow moves one step at a time, fast moves two steps.",
      "If there's a cycle, fast will eventually catch up to slow (they'll meet).",
      "If fast reaches null, there's no cycle."
    ],
    "scaffolds": {
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef hasCycle(head):\n    # Return True if the linked list has a cycle\n    pass",
      "javascript": "function ListNode(val) {\n  this.val = val;\n  this.next = null;\n}\n\nfunction hasCycle(head) {\n  // Return true if the linked list has a cycle\n}",
      "go": "package main\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc hasCycle(head *ListNode) bool {\n\t// Return true if the linked list has a cycle\n\treturn false\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        // Return true if the linked list has a cycle\n        return false;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Rc<RefCell<ListNode>>>,\n}\n\nfn has_cycle(head: Option<Rc<RefCell<ListNode>>>) -> bool {\n    // Return true if the linked list has a cycle\n    false\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nbool hasCycle(struct ListNode* head) {\n    // Return true if the linked list has a cycle\n    return false;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nbool hasCycle(ListNode* head) {\n    // Return true if the linked list has a cycle\n    return false;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 42,
    "title": "Merge Two Sorted Lists",
    "slug": "merge-two-sorted-lists",
    "difficulty": "Easy",
    "category": "Linked List",
    "description": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "examples": [
      { "input": "list1 = [1,2,4], list2 = [1,3,4]", "output": "[1,1,2,3,4,4]" },
      { "input": "list1 = [], list2 = []", "output": "[]" },
      { "input": "list1 = [], list2 = [0]", "output": "[0]" }
    ],
    "keywords": ["linked list", "merge", "sorted", "two pointers", "recursive"],
    "hints": [
      "Use a dummy head node to simplify the merge logic.",
      "Compare the current nodes of both lists. Append the smaller one to the result and advance that pointer.",
      "When one list is exhausted, append the remainder of the other list."
    ],
    "scaffolds": {
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(list1, list2):\n    # Merge two sorted linked lists\n    pass",
      "javascript": "function ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction mergeTwoLists(list1, list2) {\n  // Merge two sorted linked lists\n}",
      "go": "package main\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n\t// Merge two sorted linked lists\n\treturn nil\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // Merge two sorted linked lists\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    // Merge two sorted linked lists\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    // Merge two sorted linked lists\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    // Merge two sorted linked lists\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 43,
    "title": "Merge K Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Hard",
    "category": "Linked List",
    "description": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
    "examples": [
      { "input": "lists = [[1,4,5],[1,3,4],[2,6]]", "output": "[1,1,2,3,4,4,5,6]" },
      { "input": "lists = []", "output": "[]" },
      { "input": "lists = [[]]", "output": "[]" }
    ],
    "keywords": ["linked list", "merge", "heap", "priority queue", "divide and conquer"],
    "hints": [
      "Use a min-heap (priority queue) to always pick the smallest current node across all lists.",
      "Push the head of each list into the heap. Pop the smallest, add it to the result, push its next node.",
      "Alternatively, use divide and conquer: merge pairs of lists, halving the count each round."
    ],
    "scaffolds": {
      "python": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists):\n    # Merge k sorted linked lists into one\n    pass",
      "javascript": "function ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction mergeKLists(lists) {\n  // Merge k sorted linked lists into one\n}",
      "go": "package main\n\nimport \"container/heap\"\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc mergeKLists(lists []*ListNode) *ListNode {\n\t// Merge k sorted linked lists into one\n\treturn nil\n}\n\nfunc main() {}",
      "java": "import java.util.*;\n\npublic class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static ListNode mergeKLists(ListNode[] lists) {\n        // Merge k sorted linked lists into one\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n    // Merge k sorted linked lists into one\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    // Merge k sorted linked lists into one\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* mergeKLists(vector<ListNode*>& lists) {\n    // Merge k sorted linked lists into one\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 44,
    "title": "Remove Nth Node From End of List",
    "slug": "remove-nth-node-from-end-of-list",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its head.",
    "examples": [
      { "input": "head = [1,2,3,4,5], n = 2", "output": "[1,2,3,5]" },
      { "input": "head = [1], n = 1", "output": "[]" },
      { "input": "head = [1,2], n = 1", "output": "[1]" }
    ],
    "keywords": ["linked list", "two pointers", "fast slow", "remove", "nth from end"],
    "hints": [
      "Use two pointers separated by n nodes. When the fast pointer reaches the end, slow is at the target.",
      "Advance fast n steps first. Then move both fast and slow together until fast reaches the end.",
      "Use a dummy node before head to handle the case where the head itself needs to be removed."
    ],
    "scaffolds": {
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    # Remove the nth node from the end and return the head\n    pass",
      "javascript": "function ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction removeNthFromEnd(head, n) {\n  // Remove the nth node from the end and return the head\n}",
      "go": "package main\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n\t// Remove the nth node from the end and return the head\n\treturn nil\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static ListNode removeNthFromEnd(ListNode head, int n) {\n        // Remove the nth node from the end and return the head\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n    // Remove the nth node from the end and return the head\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    // Remove the nth node from the end and return the head\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    // Remove the nth node from the end and return the head\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 45,
    "title": "Reorder List",
    "slug": "reorder-list",
    "difficulty": "Medium",
    "category": "Linked List",
    "description": "You are given the head of a singly linked-list:\n\n`L0 -> L1 -> ... -> Ln-1 -> Ln`\n\nReorder the list to be in the following form:\n\n`L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...`\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "examples": [
      { "input": "head = [1,2,3,4]", "output": "[1,4,2,3]" },
      { "input": "head = [1,2,3,4,5]", "output": "[1,5,2,4,3]" }
    ],
    "keywords": ["linked list", "reverse", "merge", "fast slow", "middle"],
    "hints": [
      "Three steps: find the middle, reverse the second half, merge the two halves.",
      "Use slow/fast pointers to find the middle. Reverse the list from mid.next onward.",
      "Interleave nodes from the first half and the reversed second half."
    ],
    "scaffolds": {
      "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reorderList(head):\n    # Reorder the list in-place: L0->Ln->L1->Ln-1->...\n    pass",
      "javascript": "function ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction reorderList(head) {\n  // Reorder the list in-place: L0->Ln->L1->Ln-1->...\n}",
      "go": "package main\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc reorderList(head *ListNode) {\n\t// Reorder the list in-place: L0->Ln->L1->Ln-1->...\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) { this.val = val; }\n    }\n\n    public static void reorderList(ListNode head) {\n        // Reorder the list in-place: L0->Ln->L1->Ln-1->...\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn reorder_list(head: &mut Option<Box<ListNode>>) {\n    // Reorder the list in-place: L0->Ln->L1->Ln-1->...\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nvoid reorderList(struct ListNode* head) {\n    // Reorder the list in-place: L0->Ln->L1->Ln-1->...\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nvoid reorderList(ListNode* head) {\n    // Reorder the list in-place: L0->Ln->L1->Ln-1->...\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 46,
    "title": "Set Matrix Zeroes",
    "slug": "set-matrix-zeroes",
    "difficulty": "Medium",
    "category": "Matrix",
    "description": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.",
    "examples": [
      { "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]", "output": "[[1,0,1],[0,0,0],[1,0,1]]" },
      { "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]", "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]" }
    ],
    "keywords": ["matrix", "in-place", "zero", "row", "column", "marker"],
    "hints": [
      "O(m+n) space: use separate arrays to mark which rows and columns should be zeroed.",
      "O(1) space: use the first row and first column of the matrix itself as markers.",
      "Process the matrix in two passes: first mark, then zero out. Handle the first row/column separately."
    ],
    "scaffolds": {
      "python": "def setZeroes(matrix):\n    # Set entire row and column to 0 if element is 0\n    pass\n\n# Example usage:\nm = [[1,1,1],[1,0,1],[1,1,1]]\nsetZeroes(m)\nprint(m)",
      "javascript": "function setZeroes(matrix) {\n  // Set entire row and column to 0 if element is 0\n}\n\n// Example usage:\nconst m = [[1,1,1],[1,0,1],[1,1,1]];\nsetZeroes(m);\nconsole.log(m);",
      "go": "package main\n\nimport \"fmt\"\n\nfunc setZeroes(matrix [][]int) {\n\t// Set entire row and column to 0 if element is 0\n}\n\nfunc main() {\n\tm := [][]int{{1,1,1},{1,0,1},{1,1,1}}\n\tsetZeroes(m)\n\tfmt.Println(m)\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static void setZeroes(int[][] matrix) {\n        // Set entire row and column to 0 if element is 0\n    }\n\n    public static void main(String[] args) {\n        int[][] m = {{1,1,1},{1,0,1},{1,1,1}};\n        setZeroes(m);\n        System.out.println(Arrays.deepToString(m));\n    }\n}",
      "rust": "fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n    // Set entire row and column to 0 if element is 0\n}\n\nfn main() {\n    let mut m = vec![vec![1,1,1],vec![1,0,1],vec![1,1,1]];\n    set_zeroes(&mut m);\n    println!(\"{:?}\", m);\n}",
      "c": "#include <stdio.h>\n\nvoid setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    // Set entire row and column to 0 if element is 0\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid setZeroes(vector<vector<int>>& matrix) {\n    // Set entire row and column to 0 if element is 0\n}\n\nint main() {\n    vector<vector<int>> m = {{1,1,1},{1,0,1},{1,1,1}};\n    setZeroes(m);\n    for (auto& row : m) { for (int x : row) cout << x << \" \"; cout << endl; }\n    return 0;\n}"
    }
  },
  {
    "id": 47,
    "title": "Spiral Matrix",
    "slug": "spiral-matrix",
    "difficulty": "Medium",
    "category": "Matrix",
    "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
    "examples": [
      { "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]", "output": "[1,2,3,6,9,8,7,4,5]" },
      { "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]", "output": "[1,2,3,4,8,12,11,10,9,5,6,7]" }
    ],
    "keywords": ["matrix", "spiral", "simulation", "boundary", "traversal"],
    "hints": [
      "Use four boundaries: top, bottom, left, right. Traverse right, down, left, up and shrink boundaries.",
      "After each direction, check if boundaries have crossed before continuing.",
      "Continue until all elements are visited (result length == m * n)."
    ],
    "scaffolds": {
      "python": "def spiralOrder(matrix):\n    # Return elements in spiral order\n    pass\n\n# Example usage:\nprint(spiralOrder([[1,2,3],[4,5,6],[7,8,9]]))",
      "javascript": "function spiralOrder(matrix) {\n  // Return elements in spiral order\n}\n\n// Example usage:\nconsole.log(spiralOrder([[1,2,3],[4,5,6],[7,8,9]]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc spiralOrder(matrix [][]int) []int {\n\t// Return elements in spiral order\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(spiralOrder([][]int{{1,2,3},{4,5,6},{7,8,9}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static List<Integer> spiralOrder(int[][] matrix) {\n        // Return elements in spiral order\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(spiralOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}}));\n    }\n}",
      "rust": "fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n    // Return elements in spiral order\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", spiral_order(vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]]));\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    // Return elements in spiral order\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    // Return elements in spiral order\n    return {};\n}\n\nint main() {\n    vector<vector<int>> m = {{1,2,3},{4,5,6},{7,8,9}};\n    auto res = spiralOrder(m);\n    for (int x : res) cout << x << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 48,
    "title": "Rotate Image",
    "slug": "rotate-image",
    "difficulty": "Medium",
    "category": "Matrix",
    "description": "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "examples": [
      { "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]", "output": "[[7,4,1],[8,5,2],[9,6,3]]" },
      { "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]", "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]" }
    ],
    "keywords": ["matrix", "rotate", "transpose", "in-place", "90 degrees"],
    "hints": [
      "Rotating 90 degrees clockwise = transpose the matrix + reverse each row.",
      "Transpose: swap matrix[i][j] with matrix[j][i] for all i < j.",
      "Then reverse each row in place."
    ],
    "scaffolds": {
      "python": "def rotate(matrix):\n    # Rotate the matrix 90 degrees clockwise in-place\n    pass\n\n# Example usage:\nm = [[1,2,3],[4,5,6],[7,8,9]]\nrotate(m)\nprint(m)",
      "javascript": "function rotate(matrix) {\n  // Rotate the matrix 90 degrees clockwise in-place\n}\n\n// Example usage:\nconst m = [[1,2,3],[4,5,6],[7,8,9]];\nrotate(m);\nconsole.log(m);",
      "go": "package main\n\nimport \"fmt\"\n\nfunc rotate(matrix [][]int) {\n\t// Rotate the matrix 90 degrees clockwise in-place\n}\n\nfunc main() {\n\tm := [][]int{{1,2,3},{4,5,6},{7,8,9}}\n\trotate(m)\n\tfmt.Println(m)\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static void rotate(int[][] matrix) {\n        // Rotate the matrix 90 degrees clockwise in-place\n    }\n\n    public static void main(String[] args) {\n        int[][] m = {{1,2,3},{4,5,6},{7,8,9}};\n        rotate(m);\n        System.out.println(Arrays.deepToString(m));\n    }\n}",
      "rust": "fn rotate(matrix: &mut Vec<Vec<i32>>) {\n    // Rotate the matrix 90 degrees clockwise in-place\n}\n\nfn main() {\n    let mut m = vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]];\n    rotate(&mut m);\n    println!(\"{:?}\", m);\n}",
      "c": "#include <stdio.h>\n\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize) {\n    // Rotate the matrix 90 degrees clockwise in-place\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid rotate(vector<vector<int>>& matrix) {\n    // Rotate the matrix 90 degrees clockwise in-place\n}\n\nint main() {\n    vector<vector<int>> m = {{1,2,3},{4,5,6},{7,8,9}};\n    rotate(m);\n    for (auto& row : m) { for (int x : row) cout << x << \" \"; cout << endl; }\n    return 0;\n}"
    }
  },
  {
    "id": 49,
    "title": "Word Search",
    "slug": "word-search",
    "difficulty": "Medium",
    "category": "Matrix",
    "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "examples": [
      { "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"", "output": "true" },
      { "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"", "output": "true" },
      { "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"", "output": "false" }
    ],
    "keywords": ["matrix", "backtracking", "dfs", "word search", "recursion"],
    "hints": [
      "Try starting from every cell. Use DFS/backtracking to explore all four directions.",
      "Mark cells as visited (e.g., replace with '#') to avoid reusing them. Restore after backtracking.",
      "Base case: if all characters matched, return true. Prune: if out of bounds or character doesn't match, return false."
    ],
    "scaffolds": {
      "python": "def exist(board, word):\n    # Return True if word exists in the grid\n    pass\n\n# Example usage:\nprint(exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\"))",
      "javascript": "function exist(board, word) {\n  // Return true if word exists in the grid\n}\n\n// Example usage:\nconsole.log(exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc exist(board [][]byte, word string) bool {\n\t// Return true if word exists in the grid\n\treturn false\n}\n\nfunc main() {\n\tboard := [][]byte{{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}\n\tfmt.Println(exist(board, \"ABCCED\"))\n}",
      "java": "public class Solution {\n    public static boolean exist(char[][] board, String word) {\n        // Return true if word exists in the grid\n        return false;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        System.out.println(exist(board, \"ABCCED\"));\n    }\n}",
      "rust": "fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n    // Return true if word exists in the grid\n    false\n}\n\nfn main() {\n    let board = vec![vec!['A','B','C','E'],vec!['S','F','C','S'],vec!['A','D','E','E']];\n    println!(\"{}\", exist(board, \"ABCCED\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    // Return true if word exists in the grid\n    return false;\n}\n\nint main() {\n    printf(\"false\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool exist(vector<vector<char>>& board, string word) {\n    // Return true if word exists in the grid\n    return false;\n}\n\nint main() {\n    vector<vector<char>> board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n    cout << boolalpha << exist(board, \"ABCCED\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 50,
    "title": "Longest Substring Without Repeating Characters",
    "slug": "longest-substring-without-repeating-characters",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
    "examples": [
      { "input": "s = \"abcabcbb\"", "output": "3", "explanation": "The answer is \"abc\", with the length of 3." },
      { "input": "s = \"bbbbb\"", "output": "1" },
      { "input": "s = \"pwwkew\"", "output": "3", "explanation": "The answer is \"wke\". Note that \"pwke\" is a subsequence, not a substring." }
    ],
    "keywords": ["string", "sliding window", "hash set", "hash map", "substring"],
    "hints": [
      "Use a sliding window with two pointers (left and right) and a set to track characters in the window.",
      "Expand right. If the character is already in the set, shrink from the left until it's removed.",
      "Track the maximum window size throughout."
    ],
    "scaffolds": {
      "python": "def lengthOfLongestSubstring(s):\n    # Return the length of the longest substring without repeating characters\n    pass\n\n# Example usage:\nprint(lengthOfLongestSubstring(\"abcabcbb\"))",
      "javascript": "function lengthOfLongestSubstring(s) {\n  // Return the length of the longest substring without repeating characters\n}\n\n// Example usage:\nconsole.log(lengthOfLongestSubstring(\"abcabcbb\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc lengthOfLongestSubstring(s string) int {\n\t// Return the length of the longest substring without repeating characters\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(lengthOfLongestSubstring(\"abcabcbb\"))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int lengthOfLongestSubstring(String s) {\n        // Return the length of the longest substring without repeating characters\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(lengthOfLongestSubstring(\"abcabcbb\"));\n    }\n}",
      "rust": "use std::collections::HashSet;\n\nfn length_of_longest_substring(s: String) -> i32 {\n    // Return the length of the longest substring without repeating characters\n    0\n}\n\nfn main() {\n    println!(\"{}\", length_of_longest_substring(\"abcabcbb\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint lengthOfLongestSubstring(char* s) {\n    // Return the length of the longest substring without repeating characters\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", lengthOfLongestSubstring(\"abcabcbb\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    // Return the length of the longest substring without repeating characters\n    return 0;\n}\n\nint main() {\n    cout << lengthOfLongestSubstring(\"abcabcbb\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 51,
    "title": "Longest Repeating Character Replacement",
    "slug": "longest-repeating-character-replacement",
    "difficulty": "Medium",
    "category": "String",
    "description": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
    "examples": [
      { "input": "s = \"ABAB\", k = 2", "output": "4", "explanation": "Replace the two 'A's with two 'B's or vice versa." },
      { "input": "s = \"AABABBA\", k = 1", "output": "4" }
    ],
    "keywords": ["string", "sliding window", "frequency", "character replacement"],
    "hints": [
      "Use a sliding window. Track the frequency of each character in the window.",
      "The window is valid if (window size - max frequency) <= k. This means we need at most k replacements.",
      "If the window becomes invalid, shrink from the left. Track the maximum valid window size."
    ],
    "scaffolds": {
      "python": "def characterReplacement(s, k):\n    # Return the longest substring with same letter after at most k replacements\n    pass\n\n# Example usage:\nprint(characterReplacement(\"ABAB\", 2))",
      "javascript": "function characterReplacement(s, k) {\n  // Return the longest substring with same letter after at most k replacements\n}\n\n// Example usage:\nconsole.log(characterReplacement(\"ABAB\", 2));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc characterReplacement(s string, k int) int {\n\t// Return the longest substring with same letter after at most k replacements\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(characterReplacement(\"ABAB\", 2))\n}",
      "java": "public class Solution {\n    public static int characterReplacement(String s, int k) {\n        // Return the longest substring with same letter after at most k replacements\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(characterReplacement(\"ABAB\", 2));\n    }\n}",
      "rust": "fn character_replacement(s: String, k: i32) -> i32 {\n    // Return the longest substring with same letter after at most k replacements\n    0\n}\n\nfn main() {\n    println!(\"{}\", character_replacement(\"ABAB\".into(), 2));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint characterReplacement(char* s, int k) {\n    // Return the longest substring with same letter after at most k replacements\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", characterReplacement(\"ABAB\", 2));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint characterReplacement(string s, int k) {\n    // Return the longest substring with same letter after at most k replacements\n    return 0;\n}\n\nint main() {\n    cout << characterReplacement(\"ABAB\", 2) << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 52,
    "title": "Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Hard",
    "category": "String",
    "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.\n\nThe answer is guaranteed to be unique.",
    "examples": [
      { "input": "s = \"ADOBECODEBANC\", t = \"ABC\"", "output": "\"BANC\"" },
      { "input": "s = \"a\", t = \"a\"", "output": "\"a\"" },
      { "input": "s = \"a\", t = \"aa\"", "output": "\"\"" }
    ],
    "keywords": ["string", "sliding window", "hash map", "two pointers", "minimum window"],
    "hints": [
      "Use a sliding window with two pointers. Expand right to include characters, shrink left to minimize.",
      "Use a frequency map for t. Track how many characters are satisfied in the current window.",
      "When all characters are satisfied, try shrinking from the left while recording the minimum window."
    ],
    "scaffolds": {
      "python": "def minWindow(s, t):\n    # Return the minimum window substring containing all characters of t\n    pass\n\n# Example usage:\nprint(minWindow(\"ADOBECODEBANC\", \"ABC\"))",
      "javascript": "function minWindow(s, t) {\n  // Return the minimum window substring containing all characters of t\n}\n\n// Example usage:\nconsole.log(minWindow(\"ADOBECODEBANC\", \"ABC\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc minWindow(s string, t string) string {\n\t// Return the minimum window substring containing all characters of t\n\treturn \"\"\n}\n\nfunc main() {\n\tfmt.Println(minWindow(\"ADOBECODEBANC\", \"ABC\"))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static String minWindow(String s, String t) {\n        // Return the minimum window substring containing all characters of t\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(minWindow(\"ADOBECODEBANC\", \"ABC\"));\n    }\n}",
      "rust": "use std::collections::HashMap;\n\nfn min_window(s: String, t: String) -> String {\n    // Return the minimum window substring containing all characters of t\n    String::new()\n}\n\nfn main() {\n    println!(\"{}\", min_window(\"ADOBECODEBANC\".into(), \"ABC\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nchar* minWindow(char* s, char* t) {\n    // Return the minimum window substring containing all characters of t\n    static char result[1] = \"\";\n    return result;\n}\n\nint main() {\n    printf(\"%s\\n\", minWindow(\"ADOBECODEBANC\", \"ABC\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nstring minWindow(string s, string t) {\n    // Return the minimum window substring containing all characters of t\n    return \"\";\n}\n\nint main() {\n    cout << minWindow(\"ADOBECODEBANC\", \"ABC\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 53,
    "title": "Valid Anagram",
    "slug": "valid-anagram",
    "difficulty": "Easy",
    "category": "String",
    "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      { "input": "s = \"anagram\", t = \"nagaram\"", "output": "true" },
      { "input": "s = \"rat\", t = \"car\"", "output": "false" }
    ],
    "keywords": ["string", "hash map", "sorting", "anagram", "frequency"],
    "hints": [
      "If the strings have different lengths, they can't be anagrams.",
      "Count the frequency of each character in both strings and compare.",
      "Alternatively, sort both strings and check if they're equal."
    ],
    "scaffolds": {
      "python": "def isAnagram(s, t):\n    # Return True if t is an anagram of s\n    pass\n\n# Example usage:\nprint(isAnagram(\"anagram\", \"nagaram\"))",
      "javascript": "function isAnagram(s, t) {\n  // Return true if t is an anagram of s\n}\n\n// Example usage:\nconsole.log(isAnagram(\"anagram\", \"nagaram\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc isAnagram(s string, t string) bool {\n\t// Return true if t is an anagram of s\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(isAnagram(\"anagram\", \"nagaram\"))\n}",
      "java": "public class Solution {\n    public static boolean isAnagram(String s, String t) {\n        // Return true if t is an anagram of s\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isAnagram(\"anagram\", \"nagaram\"));\n    }\n}",
      "rust": "fn is_anagram(s: String, t: String) -> bool {\n    // Return true if t is an anagram of s\n    false\n}\n\nfn main() {\n    println!(\"{}\", is_anagram(\"anagram\".into(), \"nagaram\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isAnagram(char* s, char* t) {\n    // Return true if t is an anagram of s\n    return false;\n}\n\nint main() {\n    printf(\"%s\\n\", isAnagram(\"anagram\", \"nagaram\") ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool isAnagram(string s, string t) {\n    // Return true if t is an anagram of s\n    return false;\n}\n\nint main() {\n    cout << boolalpha << isAnagram(\"anagram\", \"nagaram\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 54,
    "title": "Group Anagrams",
    "slug": "group-anagrams",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
    "examples": [
      { "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]" },
      { "input": "strs = [\"\"]", "output": "[[\"\"]]" },
      { "input": "strs = [\"a\"]", "output": "[[\"a\"]]" }
    ],
    "keywords": ["string", "hash map", "sorting", "anagram", "grouping"],
    "hints": [
      "Two strings are anagrams if they have the same sorted characters.",
      "Use a hash map where the key is the sorted string and the value is a list of anagrams.",
      "Alternatively, use a character count tuple/array as the key for O(n*k) instead of O(n*k*log(k))."
    ],
    "scaffolds": {
      "python": "def groupAnagrams(strs):\n    # Group anagrams together\n    pass\n\n# Example usage:\nprint(groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))",
      "javascript": "function groupAnagrams(strs) {\n  // Group anagrams together\n}\n\n// Example usage:\nconsole.log(groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc groupAnagrams(strs []string) [][]string {\n\t// Group anagrams together\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(groupAnagrams([]string{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        // Group anagrams together\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(groupAnagrams(new String[]{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}));\n    }\n}",
      "rust": "use std::collections::HashMap;\n\nfn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n    // Group anagrams together\n    vec![]\n}\n\nfn main() {\n    let strs: Vec<String> = vec![\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"].iter().map(|s| s.to_string()).collect();\n    println!(\"{:?}\", group_anagrams(strs));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Group anagrams together\n// C implementation requires manual hash map\n\nint main() {\n    printf(\"See other languages for implementation\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\n    // Group anagrams together\n    return {};\n}\n\nint main() {\n    vector<string> strs = {\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"};\n    auto res = groupAnagrams(strs);\n    for (auto& g : res) { for (auto& s : g) cout << s << \" \"; cout << endl; }\n    return 0;\n}"
    }
  },
  {
    "id": 55,
    "title": "Valid Parentheses",
    "slug": "valid-parentheses",
    "difficulty": "Easy",
    "category": "String",
    "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      { "input": "s = \"()\"", "output": "true" },
      { "input": "s = \"()[]{}\"", "output": "true" },
      { "input": "s = \"(]\"", "output": "false" }
    ],
    "keywords": ["string", "stack", "parentheses", "brackets", "matching"],
    "hints": [
      "Use a stack data structure. What should you push and when should you pop?",
      "When you encounter an opening bracket, push it onto the stack. When you encounter a closing bracket, check if it matches the top of the stack.",
      "If the stack is empty when you encounter a closing bracket, or the brackets don't match, return false. At the end, the stack should be empty."
    ],
    "scaffolds": {
      "python": "def isValid(s):\n    # Return True if the string has valid parentheses\n    pass\n\n# Example usage:\nprint(isValid(\"()[]{}\"))",
      "javascript": "function isValid(s) {\n  // Return true if the string has valid parentheses\n}\n\n// Example usage:\nconsole.log(isValid(\"()[]{}\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc isValid(s string) bool {\n\t// Return true if the string has valid parentheses\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(isValid(\"()[]{}\"))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean isValid(String s) {\n        // Return true if the string has valid parentheses\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isValid(\"()[]{}\"));\n    }\n}",
      "rust": "fn is_valid(s: String) -> bool {\n    // Return true if the string has valid parentheses\n    false\n}\n\nfn main() {\n    println!(\"{}\", is_valid(\"()[]{}\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isValid(char* s) {\n    // Return true if the string has valid parentheses\n    return false;\n}\n\nint main() {\n    printf(\"%s\\n\", isValid(\"()[]{}\") ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool isValid(string s) {\n    // Return true if the string has valid parentheses\n    return false;\n}\n\nint main() {\n    cout << boolalpha << isValid(\"()[]{}\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 56,
    "title": "Valid Palindrome",
    "slug": "valid-palindrome",
    "difficulty": "Easy",
    "category": "String",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
    "examples": [
      { "input": "s = \"A man, a plan, a canal: Panama\"", "output": "true", "explanation": "\"amanaplanacanalpanama\" is a palindrome." },
      { "input": "s = \"race a car\"", "output": "false" },
      { "input": "s = \" \"", "output": "true" }
    ],
    "keywords": ["string", "two pointers", "palindrome", "alphanumeric"],
    "hints": [
      "Use two pointers: one at the start, one at the end. Skip non-alphanumeric characters.",
      "Compare characters (case-insensitive) at both pointers. If they differ, it's not a palindrome.",
      "Move both pointers inward and repeat until they meet."
    ],
    "scaffolds": {
      "python": "def isPalindrome(s):\n    # Return True if s is a valid palindrome\n    pass\n\n# Example usage:\nprint(isPalindrome(\"A man, a plan, a canal: Panama\"))",
      "javascript": "function isPalindrome(s) {\n  // Return true if s is a valid palindrome\n}\n\n// Example usage:\nconsole.log(isPalindrome(\"A man, a plan, a canal: Panama\"));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc isPalindrome(s string) bool {\n\t// Return true if s is a valid palindrome\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(isPalindrome(\"A man, a plan, a canal: Panama\"))\n}",
      "java": "public class Solution {\n    public static boolean isPalindrome(String s) {\n        // Return true if s is a valid palindrome\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"A man, a plan, a canal: Panama\"));\n    }\n}",
      "rust": "fn is_palindrome(s: String) -> bool {\n    // Return true if s is a valid palindrome\n    false\n}\n\nfn main() {\n    println!(\"{}\", is_palindrome(\"A man, a plan, a canal: Panama\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n#include <string.h>\n\nbool isPalindrome(char* s) {\n    // Return true if s is a valid palindrome\n    return false;\n}\n\nint main() {\n    printf(\"%s\\n\", isPalindrome(\"A man, a plan, a canal: Panama\") ? \"true\" : \"false\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nbool isPalindrome(string s) {\n    // Return true if s is a valid palindrome\n    return false;\n}\n\nint main() {\n    cout << boolalpha << isPalindrome(\"A man, a plan, a canal: Panama\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 57,
    "title": "Longest Palindromic Substring",
    "slug": "longest-palindromic-substring",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given a string `s`, return the longest palindromic substring in `s`.",
    "examples": [
      { "input": "s = \"babad\"", "output": "\"bab\"", "explanation": "\"aba\" is also a valid answer." },
      { "input": "s = \"cbbd\"", "output": "\"bb\"" }
    ],
    "keywords": ["string", "dynamic programming", "expand around center", "palindrome", "manacher"],
    "hints": [
      "For each character (and each pair of characters), expand outward while the substring is a palindrome.",
      "Check both odd-length (center is one char) and even-length (center is between two chars) palindromes.",
      "Track the longest palindrome found. This approach is O(n^2) time, O(1) space."
    ],
    "scaffolds": {
      "python": "def longestPalindrome(s):\n    # Return the longest palindromic substring\n    pass\n\n# Example usage:\nprint(longestPalindrome(\"babad\"))",
      "javascript": "function longestPalindrome(s) {\n  // Return the longest palindromic substring\n}\n\n// Example usage:\nconsole.log(longestPalindrome(\"babad\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc longestPalindrome(s string) string {\n\t// Return the longest palindromic substring\n\treturn \"\"\n}\n\nfunc main() {\n\tfmt.Println(longestPalindrome(\"babad\"))\n}",
      "java": "public class Solution {\n    public static String longestPalindrome(String s) {\n        // Return the longest palindromic substring\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(longestPalindrome(\"babad\"));\n    }\n}",
      "rust": "fn longest_palindrome(s: String) -> String {\n    // Return the longest palindromic substring\n    String::new()\n}\n\nfn main() {\n    println!(\"{}\", longest_palindrome(\"babad\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nchar* longestPalindrome(char* s) {\n    // Return the longest palindromic substring\n    static char result[1001];\n    result[0] = '\\0';\n    return result;\n}\n\nint main() {\n    printf(\"%s\\n\", longestPalindrome(\"babad\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring longestPalindrome(string s) {\n    // Return the longest palindromic substring\n    return \"\";\n}\n\nint main() {\n    cout << longestPalindrome(\"babad\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 58,
    "title": "Palindromic Substrings",
    "slug": "palindromic-substrings",
    "difficulty": "Medium",
    "category": "String",
    "description": "Given a string `s`, return the number of palindromic substrings in it.\n\nA string is a palindrome when it reads the same backward as forward.\n\nA substring is a contiguous sequence of characters within the string.",
    "examples": [
      { "input": "s = \"abc\"", "output": "3", "explanation": "Three palindromic substrings: \"a\", \"b\", \"c\"." },
      { "input": "s = \"aaa\"", "output": "6", "explanation": "Six palindromic substrings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"." }
    ],
    "keywords": ["string", "dynamic programming", "expand around center", "palindrome", "count"],
    "hints": [
      "Use the expand-around-center technique for each possible center.",
      "For each index, expand for both odd-length and even-length palindromes.",
      "Count each valid expansion as a palindromic substring."
    ],
    "scaffolds": {
      "python": "def countSubstrings(s):\n    # Return the number of palindromic substrings\n    pass\n\n# Example usage:\nprint(countSubstrings(\"aaa\"))",
      "javascript": "function countSubstrings(s) {\n  // Return the number of palindromic substrings\n}\n\n// Example usage:\nconsole.log(countSubstrings(\"aaa\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc countSubstrings(s string) int {\n\t// Return the number of palindromic substrings\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(countSubstrings(\"aaa\"))\n}",
      "java": "public class Solution {\n    public static int countSubstrings(String s) {\n        // Return the number of palindromic substrings\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countSubstrings(\"aaa\"));\n    }\n}",
      "rust": "fn count_substrings(s: String) -> i32 {\n    // Return the number of palindromic substrings\n    0\n}\n\nfn main() {\n    println!(\"{}\", count_substrings(\"aaa\".into()));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint countSubstrings(char* s) {\n    // Return the number of palindromic substrings\n    return 0;\n}\n\nint main() {\n    printf(\"%d\\n\", countSubstrings(\"aaa\"));\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint countSubstrings(string s) {\n    // Return the number of palindromic substrings\n    return 0;\n}\n\nint main() {\n    cout << countSubstrings(\"aaa\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 59,
    "title": "Encode and Decode Strings",
    "slug": "encode-and-decode-strings",
    "difficulty": "Medium",
    "category": "String",
    "description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nImplement `encode` and `decode` methods.",
    "examples": [
      { "input": "strs = [\"lint\",\"code\",\"love\",\"you\"]", "output": "[\"lint\",\"code\",\"love\",\"you\"]" },
      { "input": "strs = [\"we\",\"say\",\":\",\"yes\"]", "output": "[\"we\",\"say\",\":\",\"yes\"]" }
    ],
    "keywords": ["string", "encode", "decode", "serialization", "delimiter", "length prefix"],
    "hints": [
      "You can't just use a delimiter because the strings themselves might contain it.",
      "Use length-prefixed encoding: for each string, store its length followed by a separator, then the string.",
      "Format: \"4#lint4#code4#love3#you\". To decode, read the length, skip the separator, read that many characters."
    ],
    "scaffolds": {
      "python": "def encode(strs):\n    # Encode a list of strings to a single string\n    pass\n\ndef decode(s):\n    # Decode a single string back to a list of strings\n    pass\n\n# Example usage:\nencoded = encode([\"lint\", \"code\", \"love\", \"you\"])\nprint(decode(encoded))",
      "javascript": "function encode(strs) {\n  // Encode a list of strings to a single string\n}\n\nfunction decode(s) {\n  // Decode a single string back to a list of strings\n}\n\n// Example usage:\nconst encoded = encode([\"lint\", \"code\", \"love\", \"you\"]);\nconsole.log(decode(encoded));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc encode(strs []string) string {\n\t// Encode a list of strings to a single string\n\treturn \"\"\n}\n\nfunc decode(s string) []string {\n\t// Decode a single string back to a list of strings\n\treturn nil\n}\n\nfunc main() {\n\tencoded := encode([]string{\"lint\", \"code\", \"love\", \"you\"})\n\tfmt.Println(decode(encoded))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static String encode(List<String> strs) {\n        // Encode a list of strings to a single string\n        return \"\";\n    }\n\n    public static List<String> decode(String s) {\n        // Decode a single string back to a list of strings\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        String encoded = encode(Arrays.asList(\"lint\", \"code\", \"love\", \"you\"));\n        System.out.println(decode(encoded));\n    }\n}",
      "rust": "fn encode(strs: Vec<String>) -> String {\n    // Encode a list of strings to a single string\n    String::new()\n}\n\nfn decode(s: String) -> Vec<String> {\n    // Decode a single string back to a list of strings\n    vec![]\n}\n\nfn main() {\n    let encoded = encode(vec![\"lint\".into(), \"code\".into(), \"love\".into(), \"you\".into()]);\n    println!(\"{:?}\", decode(encoded));\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* encode(char** strs, int strsSize) {\n    // Encode a list of strings to a single string\n    return \"\";\n}\n\nchar** decode(char* s, int* returnSize) {\n    // Decode a single string back to a list of strings\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring encode(vector<string>& strs) {\n    // Encode a list of strings to a single string\n    return \"\";\n}\n\nvector<string> decode(string s) {\n    // Decode a single string back to a list of strings\n    return {};\n}\n\nint main() {\n    vector<string> strs = {\"lint\", \"code\", \"love\", \"you\"};\n    string encoded = encode(strs);\n    auto decoded = decode(encoded);\n    for (auto& s : decoded) cout << s << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 60,
    "title": "Maximum Depth of Binary Tree",
    "slug": "maximum-depth-of-binary-tree",
    "difficulty": "Easy",
    "category": "Tree",
    "description": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      { "input": "root = [3,9,20,null,null,15,7]", "output": "3" },
      { "input": "root = [1,null,2]", "output": "2" }
    ],
    "keywords": ["tree", "binary tree", "dfs", "bfs", "recursion", "depth"],
    "hints": [
      "Use recursion: the depth of a tree is 1 + max(depth of left subtree, depth of right subtree).",
      "Base case: if the node is null, return 0.",
      "Alternatively, use BFS (level-order traversal) and count the number of levels."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root):\n    # Return the maximum depth of the binary tree\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction maxDepth(root) {\n  // Return the maximum depth of the binary tree\n}",
      "go": "package main\n\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc maxDepth(root *TreeNode) int {\n\t// Return the maximum depth of the binary tree\n\treturn 0\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n    }\n\n    public static int maxDepth(TreeNode root) {\n        // Return the maximum depth of the binary tree\n        return 0;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode {\n    val: i32,\n    left: Option<Rc<RefCell<TreeNode>>>,\n    right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nfn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n    // Return the maximum depth of the binary tree\n    0\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct TreeNode {\n    int val;\n    struct TreeNode* left;\n    struct TreeNode* right;\n};\n\nint maxDepth(struct TreeNode* root) {\n    // Return the maximum depth of the binary tree\n    return 0;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nint maxDepth(TreeNode* root) {\n    // Return the maximum depth of the binary tree\n    return 0;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 61,
    "title": "Same Tree",
    "slug": "same-tree",
    "difficulty": "Easy",
    "category": "Tree",
    "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
      { "input": "p = [1,2,3], q = [1,2,3]", "output": "true" },
      { "input": "p = [1,2], q = [1,null,2]", "output": "false" },
      { "input": "p = [1,2,1], q = [1,1,2]", "output": "false" }
    ],
    "keywords": ["tree", "binary tree", "dfs", "recursion", "comparison"],
    "hints": [
      "If both nodes are null, they're the same. If only one is null, they're different.",
      "If both nodes exist, compare their values, then recursively compare left and right subtrees.",
      "Return p.val == q.val AND isSameTree(p.left, q.left) AND isSameTree(p.right, q.right)."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSameTree(p, q):\n    # Return True if both trees are identical\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction isSameTree(p, q) {\n  // Return true if both trees are identical\n}",
      "go": "package main\n\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n\t// Return true if both trees are identical\n\treturn false\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n    }\n\n    public static boolean isSameTree(TreeNode p, TreeNode q) {\n        // Return true if both trees are identical\n        return false;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n    // Return true if both trees are identical\n    false\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q) {\n    // Return true if both trees are identical\n    return false;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    // Return true if both trees are identical\n    return false;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 62,
    "title": "Invert Binary Tree",
    "slug": "invert-binary-tree",
    "difficulty": "Easy",
    "category": "Tree",
    "description": "Given the `root` of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping the left and right children of every node.",
    "examples": [
      { "input": "root = [4,2,7,1,3,6,9]", "output": "[4,7,2,9,6,3,1]" },
      { "input": "root = [2,1,3]", "output": "[2,3,1]" },
      { "input": "root = []", "output": "[]" }
    ],
    "keywords": ["tree", "binary tree", "dfs", "recursion", "invert", "mirror"],
    "hints": [
      "Recursively swap the left and right children of each node.",
      "Base case: if the node is null, return null.",
      "Swap root.left and root.right, then recursively invert both subtrees."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invertTree(root):\n    # Invert the binary tree and return the root\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction invertTree(root) {\n  // Invert the binary tree and return the root\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc invertTree(root *TreeNode) *TreeNode {\n\t// Invert the binary tree and return the root\n\treturn nil\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static TreeNode invertTree(TreeNode root) {\n        // Invert the binary tree and return the root\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Invert the binary tree and return the root\n    None\n}\n\nfn main() {}",
      "c": "#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nstruct TreeNode* invertTree(struct TreeNode* root) {\n    // Invert the binary tree and return the root\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* invertTree(TreeNode* root) {\n    // Invert the binary tree and return the root\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 63,
    "title": "Binary Tree Maximum Path Sum",
    "slug": "binary-tree-maximum-path-sum",
    "difficulty": "Hard",
    "category": "Tree",
    "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the maximum path sum of any non-empty path.",
    "examples": [
      { "input": "root = [1,2,3]", "output": "6", "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6." },
      { "input": "root = [-10,9,20,null,null,15,7]", "output": "42", "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 42." }
    ],
    "keywords": ["tree", "binary tree", "dfs", "recursion", "path sum", "post-order"],
    "hints": [
      "For each node, compute the max path sum passing through it as the 'turning point' (left + node + right).",
      "The recursive function returns the max gain from one side only (node + max(left, right, 0)) to the parent.",
      "Use a global variable to track the overall maximum path sum seen so far."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root):\n    # Return the maximum path sum in the binary tree\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction maxPathSum(root) {\n  // Return the maximum path sum in the binary tree\n}",
      "go": "package main\n\nimport \"math\"\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc maxPathSum(root *TreeNode) int {\n\t// Return the maximum path sum in the binary tree\n\tresult := math.MinInt32\n\t// DFS helper here\n\t_ = result\n\treturn 0\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static int maxPathSum(TreeNode root) {\n        // Return the maximum path sum in the binary tree\n        return 0;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n    // Return the maximum path sum in the binary tree\n    0\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <limits.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nint maxPathSum(struct TreeNode* root) {\n    // Return the maximum path sum in the binary tree\n    return 0;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nint maxPathSum(TreeNode* root) {\n    // Return the maximum path sum in the binary tree\n    return 0;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 64,
    "title": "Binary Tree Level Order Traversal",
    "slug": "binary-tree-level-order-traversal",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given the `root` of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).",
    "examples": [
      { "input": "root = [3,9,20,null,null,15,7]", "output": "[[3],[9,20],[15,7]]" },
      { "input": "root = [1]", "output": "[[1]]" },
      { "input": "root = []", "output": "[]" }
    ],
    "keywords": ["tree", "binary tree", "bfs", "queue", "level order", "traversal"],
    "hints": [
      "Use BFS with a queue. Process all nodes at the current level before moving to the next.",
      "At each level, record the queue size. Process exactly that many nodes, adding their children.",
      "Collect values at each level into a sub-array."
    ],
    "scaffolds": {
      "python": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    # Return level order traversal as a list of lists\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction levelOrder(root) {\n  // Return level order traversal as a list of lists\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc levelOrder(root *TreeNode) [][]int {\n\t// Return level order traversal as a list of lists\n\treturn nil\n}\n\nfunc main() {}",
      "java": "import java.util.*;\n\npublic class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static List<List<Integer>> levelOrder(TreeNode root) {\n        // Return level order traversal as a list of lists\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n    // Return level order traversal as a list of lists\n    vec![]\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nint** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    // Return level order traversal as a list of lists\n    *returnSize = 0;\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nvector<vector<int>> levelOrder(TreeNode* root) {\n    // Return level order traversal as a list of lists\n    return {};\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 65,
    "title": "Serialize and Deserialize Binary Tree",
    "slug": "serialize-and-deserialize-binary-tree",
    "difficulty": "Hard",
    "category": "Tree",
    "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a tree to a string, and deserialization is converting the string back to the original tree structure.\n\nThere is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
    "examples": [
      { "input": "root = [1,2,3,null,null,4,5]", "output": "[1,2,3,null,null,4,5]" },
      { "input": "root = []", "output": "[]" }
    ],
    "keywords": ["tree", "binary tree", "serialization", "bfs", "dfs", "preorder"],
    "hints": [
      "Use preorder DFS: serialize each node's value (or 'null' for empty nodes) separated by commas.",
      "To deserialize, split the string and use a queue/index to reconstruct the tree recursively.",
      "BFS approach also works: serialize level by level, using 'null' for missing children."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize(root):\n    # Encode a tree to a single string\n    pass\n\ndef deserialize(data):\n    # Decode a string back to a tree\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction serialize(root) {\n  // Encode a tree to a single string\n}\n\nfunction deserialize(data) {\n  // Decode a string back to a tree\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc serialize(root *TreeNode) string {\n\t// Encode a tree to a single string\n\treturn \"\"\n}\n\nfunc deserialize(data string) *TreeNode {\n\t// Decode a string back to a tree\n\treturn nil\n}\n\nfunc main() {}",
      "java": "import java.util.*;\n\npublic class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static String serialize(TreeNode root) {\n        // Encode a tree to a single string\n        return \"\";\n    }\n\n    public static TreeNode deserialize(String data) {\n        // Decode a string back to a tree\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn serialize(root: Option<Rc<RefCell<TreeNode>>>) -> String {\n    // Encode a tree to a single string\n    String::new()\n}\n\nfn deserialize(data: String) -> Option<Rc<RefCell<TreeNode>>> {\n    // Decode a string back to a tree\n    None\n}\n\nfn main() {}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nchar* serialize(struct TreeNode* root) {\n    // Encode a tree to a single string\n    return \"\";\n}\n\nstruct TreeNode* deserialize(char* data) {\n    // Decode a string back to a tree\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nstring serialize(TreeNode* root) {\n    // Encode a tree to a single string\n    return \"\";\n}\n\nTreeNode* deserialize(string data) {\n    // Decode a string back to a tree\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 66,
    "title": "Subtree of Another Tree",
    "slug": "subtree-of-another-tree",
    "difficulty": "Easy",
    "category": "Tree",
    "description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree is a tree that consists of a node in the tree and all of this node's descendants.",
    "examples": [
      { "input": "root = [3,4,5,1,2], subRoot = [4,1,2]", "output": "true" },
      { "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]", "output": "false" }
    ],
    "keywords": ["tree", "binary tree", "dfs", "recursion", "subtree", "same tree"],
    "hints": [
      "For each node in root, check if the subtree rooted at that node is identical to subRoot.",
      "Reuse the 'same tree' logic: two trees are the same if values match and both subtrees match.",
      "Traverse root with DFS. At each node, call isSameTree(node, subRoot)."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSubtree(root, subRoot):\n    # Return True if subRoot is a subtree of root\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction isSubtree(root, subRoot) {\n  // Return true if subRoot is a subtree of root\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc isSubtree(root *TreeNode, subRoot *TreeNode) bool {\n\t// Return true if subRoot is a subtree of root\n\treturn false\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        // Return true if subRoot is a subtree of root\n        return false;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn is_subtree(root: Option<Rc<RefCell<TreeNode>>>, sub_root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n    // Return true if sub_root is a subtree of root\n    false\n}\n\nfn main() {}",
      "c": "#include <stdbool.h>\n#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nbool isSubtree(struct TreeNode* root, struct TreeNode* subRoot) {\n    // Return true if subRoot is a subtree of root\n    return false;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nbool isSubtree(TreeNode* root, TreeNode* subRoot) {\n    // Return true if subRoot is a subtree of root\n    return false;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 67,
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.",
    "examples": [
      { "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]", "output": "[3,9,20,null,null,15,7]" },
      { "input": "preorder = [-1], inorder = [-1]", "output": "[-1]" }
    ],
    "keywords": ["tree", "binary tree", "recursion", "preorder", "inorder", "divide and conquer"],
    "hints": [
      "The first element of preorder is always the root. Find it in inorder to split left and right subtrees.",
      "Elements to the left of root in inorder form the left subtree; elements to the right form the right subtree.",
      "Use a hash map for O(1) lookup of root position in inorder. Recursively build left and right subtrees."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(preorder, inorder):\n    # Construct binary tree from preorder and inorder traversals\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction buildTree(preorder, inorder) {\n  // Construct binary tree from preorder and inorder traversals\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\t// Construct binary tree from preorder and inorder traversals\n\treturn nil\n}\n\nfunc main() {}",
      "java": "import java.util.*;\n\npublic class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\n        // Construct binary tree from preorder and inorder traversals\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n    // Construct binary tree from preorder and inorder traversals\n    None\n}\n\nfn main() {}",
      "c": "#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\n    // Construct binary tree from preorder and inorder traversals\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    // Construct binary tree from preorder and inorder traversals\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 68,
    "title": "Validate Binary Search Tree",
    "slug": "validate-binary-search-tree",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.",
    "examples": [
      { "input": "root = [2,1,3]", "output": "true" },
      { "input": "root = [5,1,4,null,null,3,6]", "output": "false", "explanation": "The root node's value is 5 but its right child's value is 4." }
    ],
    "keywords": ["tree", "binary search tree", "dfs", "recursion", "inorder", "validation"],
    "hints": [
      "Pass min and max bounds down the recursion. Each node must be within (min, max).",
      "For the left child, update max to the current node's value. For the right child, update min.",
      "Alternatively, do an inorder traversal — a valid BST produces a strictly increasing sequence."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBST(root):\n    # Return True if the tree is a valid BST\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction isValidBST(root) {\n  // Return true if the tree is a valid BST\n}",
      "go": "package main\n\nimport \"math\"\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc isValidBST(root *TreeNode) bool {\n\t// Return true if the tree is a valid BST\n\t_ = math.MinInt64\n\treturn false\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static boolean isValidBST(TreeNode root) {\n        // Return true if the tree is a valid BST\n        return false;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n    // Return true if the tree is a valid BST\n    false\n}\n\nfn main() {}",
      "c": "#include <stdbool.h>\n#include <limits.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nbool isValidBST(struct TreeNode* root) {\n    // Return true if the tree is a valid BST\n    return false;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nbool isValidBST(TreeNode* root) {\n    // Return true if the tree is a valid BST\n    return false;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 69,
    "title": "Kth Smallest Element in a BST",
    "slug": "kth-smallest-element-in-a-bst",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given the `root` of a binary search tree, and an integer `k`, return the `k`th smallest value (1-indexed) of all the values of the nodes in the tree.",
    "examples": [
      { "input": "root = [3,1,4,null,2], k = 1", "output": "1" },
      { "input": "root = [5,3,6,2,4,null,null,1], k = 3", "output": "3" }
    ],
    "keywords": ["tree", "binary search tree", "inorder", "dfs", "kth smallest", "stack"],
    "hints": [
      "Inorder traversal of a BST visits nodes in ascending order.",
      "Perform inorder traversal and return the kth element visited.",
      "You can use an iterative approach with a stack to stop early once you've found the kth element."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root, k):\n    # Return the kth smallest element in the BST\n    pass",
      "javascript": "function TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction kthSmallest(root, k) {\n  // Return the kth smallest element in the BST\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc kthSmallest(root *TreeNode, k int) int {\n\t// Return the kth smallest element in the BST\n\treturn 0\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static int kthSmallest(TreeNode root, int k) {\n        // Return the kth smallest element in the BST\n        return 0;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\n    // Return the kth smallest element in the BST\n    0\n}\n\nfn main() {}",
      "c": "#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nint kthSmallest(struct TreeNode* root, int k) {\n    // Return the kth smallest element in the BST\n    return 0;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nint kthSmallest(TreeNode* root, int k) {\n    // Return the kth smallest element in the BST\n    return 0;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 70,
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "slug": "lowest-common-ancestor-of-a-bst",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nThe lowest common ancestor is defined as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).",
    "examples": [
      { "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8", "output": "6" },
      { "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4", "output": "2" }
    ],
    "keywords": ["tree", "binary search tree", "lca", "ancestor", "recursion"],
    "hints": [
      "In a BST, if both p and q are smaller than root, LCA is in the left subtree.",
      "If both are larger, LCA is in the right subtree.",
      "If they split (one on each side), or one equals root, then root is the LCA."
    ],
    "scaffolds": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, p, q):\n    # Return the lowest common ancestor of p and q\n    pass",
      "javascript": "function TreeNode(val) {\n  this.val = val;\n  this.left = this.right = null;\n}\n\nfunction lowestCommonAncestor(root, p, q) {\n  // Return the lowest common ancestor of p and q\n}",
      "go": "package main\n\ntype TreeNode struct { Val int; Left *TreeNode; Right *TreeNode }\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\t// Return the lowest common ancestor of p and q\n\treturn nil\n}\n\nfunc main() {}",
      "java": "public class Solution {\n    static class TreeNode { int val; TreeNode left, right; TreeNode(int val) { this.val = val; } }\n\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Return the lowest common ancestor of p and q\n        return null;\n    }\n\n    public static void main(String[] args) {}\n}",
      "rust": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct TreeNode { val: i32, left: Option<Rc<RefCell<TreeNode>>>, right: Option<Rc<RefCell<TreeNode>>> }\n\nfn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: i32, q: i32) -> Option<Rc<RefCell<TreeNode>>> {\n    // Return the lowest common ancestor of p and q\n    None\n}\n\nfn main() {}",
      "c": "#include <stdlib.h>\n\nstruct TreeNode { int val; struct TreeNode* left; struct TreeNode* right; };\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    // Return the lowest common ancestor of p and q\n    return NULL;\n}\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\n\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // Return the lowest common ancestor of p and q\n    return nullptr;\n}\n\nint main() { return 0; }"
    }
  },
  {
    "id": 71,
    "title": "Implement Trie (Prefix Tree)",
    "slug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.\n\nImplement the Trie class:\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string `word` into the trie.\n- `boolean search(String word)` Returns `true` if the string `word` is in the trie.\n- `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string that has the prefix `prefix`.",
    "examples": [
      { "input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]", "output": "[null,null,true,false,true,null,true]" }
    ],
    "keywords": ["tree", "trie", "prefix tree", "string", "data structure", "insert", "search"],
    "hints": [
      "Each node has up to 26 children (one per letter) and a boolean flag marking end of word.",
      "Insert: traverse/create nodes for each character. Mark the last node as end of word.",
      "Search: traverse nodes for each character. Return true only if all characters exist and the last is marked as end. StartsWith is similar but doesn't check the end flag."
    ],
    "scaffolds": {
      "python": "class Trie:\n    def __init__(self):\n        pass\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def startsWith(self, prefix):\n        pass\n\n# Example usage:\nt = Trie()\nt.insert(\"apple\")\nprint(t.search(\"apple\"))    # True\nprint(t.startsWith(\"app\"))  # True",
      "javascript": "class Trie {\n  constructor() {}\n\n  insert(word) {\n    // Insert word into the trie\n  }\n\n  search(word) {\n    // Return true if word is in the trie\n  }\n\n  startsWith(prefix) {\n    // Return true if any word starts with prefix\n  }\n}\n\n// Example usage:\nconst t = new Trie();\nt.insert(\"apple\");\nconsole.log(t.search(\"apple\"));",
      "go": "package main\n\nimport \"fmt\"\n\ntype Trie struct {\n\t// Define trie node structure\n}\n\nfunc Constructor() Trie {\n\treturn Trie{}\n}\n\nfunc (t *Trie) Insert(word string) {}\nfunc (t *Trie) Search(word string) bool { return false }\nfunc (t *Trie) StartsWith(prefix string) bool { return false }\n\nfunc main() {\n\tt := Constructor()\n\tt.Insert(\"apple\")\n\tfmt.Println(t.Search(\"apple\"))\n}",
      "java": "public class Trie {\n    public Trie() {}\n\n    public void insert(String word) {\n        // Insert word into the trie\n    }\n\n    public boolean search(String word) {\n        // Return true if word is in the trie\n        return false;\n    }\n\n    public boolean startsWith(String prefix) {\n        // Return true if any word starts with prefix\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Trie t = new Trie();\n        t.insert(\"apple\");\n        System.out.println(t.search(\"apple\"));\n    }\n}",
      "rust": "use std::collections::HashMap;\n\nstruct Trie {\n    // Define trie node structure\n}\n\nimpl Trie {\n    fn new() -> Self { Trie {} }\n    fn insert(&mut self, word: String) {}\n    fn search(&self, word: String) -> bool { false }\n    fn starts_with(&self, prefix: String) -> bool { false }\n}\n\nfn main() {\n    let mut t = Trie::new();\n    t.insert(\"apple\".into());\n    println!(\"{}\", t.search(\"apple\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct TrieNode {\n    struct TrieNode* children[26];\n    bool isEnd;\n} Trie;\n\nTrie* trieCreate() {\n    Trie* t = (Trie*)calloc(1, sizeof(Trie));\n    return t;\n}\n\nvoid trieInsert(Trie* obj, char* word) {}\nbool trieSearch(Trie* obj, char* word) { return false; }\nbool trieStartsWith(Trie* obj, char* prefix) { return false; }\n\nint main() { return 0; }",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Trie {\npublic:\n    Trie() {}\n    void insert(string word) {}\n    bool search(string word) { return false; }\n    bool startsWith(string prefix) { return false; }\n};\n\nint main() {\n    Trie t;\n    t.insert(\"apple\");\n    cout << boolalpha << t.search(\"apple\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 72,
    "title": "Design Add and Search Words Data Structure",
    "slug": "design-add-and-search-words-data-structure",
    "difficulty": "Medium",
    "category": "Tree",
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the `WordDictionary` class:\n- `WordDictionary()` Initializes the object.\n- `void addWord(word)` Adds `word` to the data structure.\n- `bool search(word)` Returns `true` if there is any string that matches `word`. `word` may contain dots `'.'` where dots can be matched with any letter.",
    "examples": [
      { "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]", "output": "[null,null,null,null,false,true,true,true]" }
    ],
    "keywords": ["tree", "trie", "dfs", "wildcard", "pattern matching", "data structure"],
    "hints": [
      "Use a Trie for storage. addWord is standard trie insertion.",
      "For search, when you encounter a '.', try all 26 possible children recursively.",
      "If any branch matches the rest of the word, return true."
    ],
    "scaffolds": {
      "python": "class WordDictionary:\n    def __init__(self):\n        pass\n\n    def addWord(self, word):\n        pass\n\n    def search(self, word):\n        # '.' matches any single character\n        pass\n\n# Example usage:\nwd = WordDictionary()\nwd.addWord(\"bad\")\nprint(wd.search(\".ad\"))  # True",
      "javascript": "class WordDictionary {\n  constructor() {}\n\n  addWord(word) {}\n\n  search(word) {\n    // '.' matches any single character\n  }\n}\n\n// Example usage:\nconst wd = new WordDictionary();\nwd.addWord(\"bad\");\nconsole.log(wd.search(\".ad\"));",
      "go": "package main\n\nimport \"fmt\"\n\ntype WordDictionary struct {}\n\nfunc Constructor() WordDictionary { return WordDictionary{} }\nfunc (wd *WordDictionary) AddWord(word string) {}\nfunc (wd *WordDictionary) Search(word string) bool { return false }\n\nfunc main() {\n\twd := Constructor()\n\twd.AddWord(\"bad\")\n\tfmt.Println(wd.Search(\".ad\"))\n}",
      "java": "public class WordDictionary {\n    public WordDictionary() {}\n\n    public void addWord(String word) {}\n\n    public boolean search(String word) {\n        // '.' matches any single character\n        return false;\n    }\n\n    public static void main(String[] args) {\n        WordDictionary wd = new WordDictionary();\n        wd.addWord(\"bad\");\n        System.out.println(wd.search(\".ad\"));\n    }\n}",
      "rust": "struct WordDictionary {}\n\nimpl WordDictionary {\n    fn new() -> Self { WordDictionary {} }\n    fn add_word(&mut self, word: String) {}\n    fn search(&self, word: String) -> bool { false }\n}\n\nfn main() {\n    let mut wd = WordDictionary::new();\n    wd.add_word(\"bad\".into());\n    println!(\"{}\", wd.search(\".ad\".into()));\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n\n// Implement WordDictionary using a trie\n\nint main() {\n    printf(\"See other languages for implementation\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass WordDictionary {\npublic:\n    WordDictionary() {}\n    void addWord(string word) {}\n    bool search(string word) { return false; }\n};\n\nint main() {\n    WordDictionary wd;\n    wd.addWord(\"bad\");\n    cout << boolalpha << wd.search(\".ad\") << endl;\n    return 0;\n}"
    }
  },
  {
    "id": 73,
    "title": "Word Search II",
    "slug": "word-search-ii",
    "difficulty": "Hard",
    "category": "Tree",
    "description": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
    "examples": [
      { "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]", "output": "[\"eat\",\"oath\"]" },
      { "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]", "output": "[]" }
    ],
    "keywords": ["tree", "trie", "backtracking", "dfs", "matrix", "word search"],
    "hints": [
      "Build a Trie from the word list. Then DFS from each cell on the board, following the Trie.",
      "This is much more efficient than running Word Search I for each word individually.",
      "Prune branches: remove words from the Trie once found to avoid duplicates and speed up search."
    ],
    "scaffolds": {
      "python": "def findWords(board, words):\n    # Return all words from the list that exist on the board\n    pass\n\n# Example usage:\nboard = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\nprint(findWords(board, [\"oath\",\"pea\",\"eat\",\"rain\"]))",
      "javascript": "function findWords(board, words) {\n  // Return all words from the list that exist on the board\n}\n\n// Example usage:\nconst board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]];\nconsole.log(findWords(board, [\"oath\",\"pea\",\"eat\",\"rain\"]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc findWords(board [][]byte, words []string) []string {\n\t// Return all words from the list that exist on the board\n\treturn nil\n}\n\nfunc main() {\n\tboard := [][]byte{{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}}\n\tfmt.Println(findWords(board, []string{\"oath\",\"pea\",\"eat\",\"rain\"}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static List<String> findWords(char[][] board, String[] words) {\n        // Return all words from the list that exist on the board\n        return new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}};\n        System.out.println(findWords(board, new String[]{\"oath\",\"pea\",\"eat\",\"rain\"}));\n    }\n}",
      "rust": "fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n    // Return all words from the list that exist on the board\n    vec![]\n}\n\nfn main() {\n    let board = vec![vec!['o','a','a','n'],vec!['e','t','a','e'],vec!['i','h','k','r'],vec!['i','f','l','v']];\n    let words: Vec<String> = vec![\"oath\",\"pea\",\"eat\",\"rain\"].iter().map(|s| s.to_string()).collect();\n    println!(\"{:?}\", find_words(board, words));\n}",
      "c": "#include <stdio.h>\n\n// Build a trie from words, then DFS on the board\n\nint main() {\n    printf(\"See other languages for implementation\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n    // Return all words from the list that exist on the board\n    return {};\n}\n\nint main() {\n    vector<vector<char>> board = {{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}};\n    vector<string> words = {\"oath\",\"pea\",\"eat\",\"rain\"};\n    auto res = findWords(board, words);\n    for (auto& w : res) cout << w << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 74,
    "title": "Top K Frequent Elements",
    "slug": "top-k-frequent-elements",
    "difficulty": "Medium",
    "category": "Heap",
    "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
    "examples": [
      { "input": "nums = [1,1,1,2,2,3], k = 2", "output": "[1,2]" },
      { "input": "nums = [1], k = 1", "output": "[1]" }
    ],
    "keywords": ["heap", "hash map", "frequency", "bucket sort", "priority queue", "top k"],
    "hints": [
      "Count the frequency of each element using a hash map.",
      "Use a min-heap of size k to keep the top k frequent elements.",
      "Alternatively, use bucket sort: create an array where index = frequency, then collect from the end."
    ],
    "scaffolds": {
      "python": "from collections import Counter\n\ndef topKFrequent(nums, k):\n    # Return the k most frequent elements\n    pass\n\n# Example usage:\nprint(topKFrequent([1, 1, 1, 2, 2, 3], 2))",
      "javascript": "function topKFrequent(nums, k) {\n  // Return the k most frequent elements\n}\n\n// Example usage:\nconsole.log(topKFrequent([1, 1, 1, 2, 2, 3], 2));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc topKFrequent(nums []int, k int) []int {\n\t// Return the k most frequent elements\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(topKFrequent([]int{1, 1, 1, 2, 2, 3}, 2))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[] topKFrequent(int[] nums, int k) {\n        // Return the k most frequent elements\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(topKFrequent(new int[]{1, 1, 1, 2, 2, 3}, 2)));\n    }\n}",
      "rust": "use std::collections::HashMap;\n\nfn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\n    // Return the k most frequent elements\n    vec![]\n}\n\nfn main() {\n    println!(\"{:?}\", top_k_frequent(vec![1, 1, 1, 2, 2, 3], 2));\n}",
      "c": "#include <stdio.h>\n\n// Return the k most frequent elements\n\nint main() {\n    printf(\"See other languages for implementation\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvector<int> topKFrequent(vector<int>& nums, int k) {\n    // Return the k most frequent elements\n    return {};\n}\n\nint main() {\n    vector<int> nums = {1, 1, 1, 2, 2, 3};\n    auto res = topKFrequent(nums, 2);\n    for (int x : res) cout << x << \" \";\n    return 0;\n}"
    }
  },
  {
    "id": 75,
    "title": "Find Median from Data Stream",
    "slug": "find-median-from-data-stream",
    "difficulty": "Hard",
    "category": "Heap",
    "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the `MedianFinder` class:\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.",
    "examples": [
      { "input": "[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n[[],[1],[2],[],[3],[]]", "output": "[null,null,null,1.5,null,2.0]", "explanation": "After adding 1 and 2, median is (1+2)/2 = 1.5. After adding 3, median is 2." }
    ],
    "keywords": ["heap", "median", "data stream", "two heaps", "priority queue", "online algorithm"],
    "hints": [
      "Use two heaps: a max-heap for the lower half and a min-heap for the upper half.",
      "Keep them balanced: the max-heap can have at most one more element than the min-heap.",
      "The median is the top of the max-heap (odd count) or the average of both tops (even count)."
    ],
    "scaffolds": {
      "python": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        pass\n\n    def addNum(self, num):\n        pass\n\n    def findMedian(self):\n        pass\n\n# Example usage:\nmf = MedianFinder()\nmf.addNum(1)\nmf.addNum(2)\nprint(mf.findMedian())  # 1.5",
      "javascript": "class MedianFinder {\n  constructor() {}\n\n  addNum(num) {}\n\n  findMedian() {}\n}\n\n// Example usage:\nconst mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nconsole.log(mf.findMedian());",
      "go": "package main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\ntype MedianFinder struct {}\n\nfunc Constructor() MedianFinder { return MedianFinder{} }\nfunc (mf *MedianFinder) AddNum(num int) {}\nfunc (mf *MedianFinder) FindMedian() float64 { return 0.0 }\n\nfunc main() {\n\tmf := Constructor()\n\tmf.AddNum(1)\n\tmf.AddNum(2)\n\tfmt.Println(mf.FindMedian())\n\t_ = heap.Init\n}",
      "java": "import java.util.*;\n\npublic class MedianFinder {\n    public MedianFinder() {}\n\n    public void addNum(int num) {}\n\n    public double findMedian() { return 0.0; }\n\n    public static void main(String[] args) {\n        MedianFinder mf = new MedianFinder();\n        mf.addNum(1);\n        mf.addNum(2);\n        System.out.println(mf.findMedian());\n    }\n}",
      "rust": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\nstruct MedianFinder {}\n\nimpl MedianFinder {\n    fn new() -> Self { MedianFinder {} }\n    fn add_num(&mut self, num: i32) {}\n    fn find_median(&self) -> f64 { 0.0 }\n}\n\nfn main() {\n    let mut mf = MedianFinder::new();\n    mf.add_num(1);\n    mf.add_num(2);\n    println!(\"{}\", mf.find_median());\n}",
      "c": "#include <stdio.h>\n\n// Implement MedianFinder using two heaps\n\nint main() {\n    printf(\"See other languages for implementation\\n\");\n    return 0;\n}",
      "cpp": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass MedianFinder {\npublic:\n    MedianFinder() {}\n    void addNum(int num) {}\n    double findMedian() { return 0.0; }\n};\n\nint main() {\n    MedianFinder mf;\n    mf.addNum(1);\n    mf.addNum(2);\n    cout << mf.findMedian() << endl;\n    return 0;\n}"
    }
  }
]
