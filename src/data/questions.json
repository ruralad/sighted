[
  {
    "id": 1,
    "title": "Two Sum",
    "slug": "two-sum",
    "difficulty": "Easy",
    "category": "Array",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]"
      }
    ],
    "hints": [
      "A brute force approach would check every pair of numbers. Can you do better?",
      "Think about what value you need to find for each element â€” the complement (target - nums[i]).",
      "Use a hash map to store each number's index as you iterate once through the array."
    ],
    "scaffolds": {
      "python": "def twoSum(nums, target):\n    # Return indices of two numbers that add up to target\n    pass\n\n# Example usage:\nprint(twoSum([2, 7, 11, 15], 9))",
      "javascript": "function twoSum(nums, target) {\n  // Return indices of two numbers that add up to target\n}\n\n// Example usage:\nconsole.log(twoSum([2, 7, 11, 15], 9));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc twoSum(nums []int, target int) []int {\n\t// Return indices of two numbers that add up to target\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(twoSum([]int{2, 7, 11, 15}, 9))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[] twoSum(int[] nums, int target) {\n        // Return indices of two numbers that add up to target\n        return new int[]{};\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(twoSum(new int[]{2, 7, 11, 15}, 9)));\n    }\n}"
    }
  },
  {
    "id": 2,
    "title": "Valid Parentheses",
    "slug": "valid-parentheses",
    "difficulty": "Easy",
    "category": "String",
    "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "hints": [
      "Use a stack data structure. What should you push and when should you pop?",
      "When you encounter an opening bracket, push it onto the stack. When you encounter a closing bracket, check if it matches the top of the stack.",
      "If the stack is empty when you encounter a closing bracket, or the brackets don't match, return false. At the end, the stack should be empty."
    ],
    "scaffolds": {
      "python": "def isValid(s):\n    # Return True if the string has valid parentheses\n    pass\n\n# Example usage:\nprint(isValid(\"()[]{}\"))",
      "javascript": "function isValid(s) {\n  // Return true if the string has valid parentheses\n}\n\n// Example usage:\nconsole.log(isValid(\"()[]{}\"));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc isValid(s string) bool {\n\t// Return true if the string has valid parentheses\n\treturn false\n}\n\nfunc main() {\n\tfmt.Println(isValid(\"()[]{}\"))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static boolean isValid(String s) {\n        // Return true if the string has valid parentheses\n        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isValid(\"()[]{}\"));\n    }\n}"
    }
  },
  {
    "id": 3,
    "title": "Maximum Subarray",
    "slug": "maximum-subarray",
    "difficulty": "Medium",
    "category": "Array",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "hints": [
      "Think about this problem element by element. At each position, should you extend the current subarray or start a new one?",
      "Kadane's Algorithm: keep a running sum. If the running sum becomes negative, reset it to 0 (start fresh).",
      "Track two values: currentSum (max sum ending at current position) and maxSum (global maximum). currentSum = max(nums[i], currentSum + nums[i])."
    ],
    "scaffolds": {
      "python": "def maxSubArray(nums):\n    # Return the sum of the maximum subarray\n    pass\n\n# Example usage:\nprint(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))",
      "javascript": "function maxSubArray(nums) {\n  // Return the sum of the maximum subarray\n}\n\n// Example usage:\nconsole.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc maxSubArray(nums []int) int {\n\t// Return the sum of the maximum subarray\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}))\n}",
      "java": "public class Solution {\n    public static int maxSubArray(int[] nums) {\n        // Return the sum of the maximum subarray\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxSubArray(new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4}));\n    }\n}"
    }
  },
  {
    "id": 4,
    "title": "Climbing Stairs",
    "slug": "climbing-stairs",
    "difficulty": "Easy",
    "category": "Dynamic Programming",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1 step + 1 step, or 2 steps."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways: 1+1+1, 1+2, and 2+1."
      }
    ],
    "hints": [
      "Think about the relationship between the number of ways to reach step n and the steps before it.",
      "To reach step n, you can come from step n-1 (one step) or step n-2 (two steps). So ways(n) = ways(n-1) + ways(n-2).",
      "This is the Fibonacci sequence! You can solve it iteratively with O(1) space using two variables."
    ],
    "scaffolds": {
      "python": "def climbStairs(n):\n    # Return the number of distinct ways to climb n stairs\n    pass\n\n# Example usage:\nprint(climbStairs(5))",
      "javascript": "function climbStairs(n) {\n  // Return the number of distinct ways to climb n stairs\n}\n\n// Example usage:\nconsole.log(climbStairs(5));",
      "go": "package main\n\nimport \"fmt\"\n\nfunc climbStairs(n int) int {\n\t// Return the number of distinct ways to climb n stairs\n\treturn 0\n}\n\nfunc main() {\n\tfmt.Println(climbStairs(5))\n}",
      "java": "public class Solution {\n    public static int climbStairs(int n) {\n        // Return the number of distinct ways to climb n stairs\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(climbStairs(5));\n    }\n}"
    }
  },
  {
    "id": 5,
    "title": "Merge Intervals",
    "slug": "merge-intervals",
    "difficulty": "Medium",
    "category": "Interval",
    "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
      }
    ],
    "hints": [
      "Start by sorting the intervals by their start value. Why does this help?",
      "After sorting, iterate through intervals. If the current interval overlaps with the last merged interval, extend it.",
      "Two intervals overlap when the current start <= the previous end. The merged end is the max of both ends."
    ],
    "scaffolds": {
      "python": "def merge(intervals):\n    # Return merged non-overlapping intervals\n    pass\n\n# Example usage:\nprint(merge([[1,3],[2,6],[8,10],[15,18]]))",
      "javascript": "function merge(intervals) {\n  // Return merged non-overlapping intervals\n}\n\n// Example usage:\nconsole.log(merge([[1,3],[2,6],[8,10],[15,18]]));",
      "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc merge(intervals [][]int) [][]int {\n\t// Return merged non-overlapping intervals\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(merge([][]int{{1,3},{2,6},{8,10},{15,18}}))\n}",
      "java": "import java.util.*;\n\npublic class Solution {\n    public static int[][] merge(int[][] intervals) {\n        // Return merged non-overlapping intervals\n        return new int[][]{};\n    }\n\n    public static void main(String[] args) {\n        int[][] result = merge(new int[][]{{1,3},{2,6},{8,10},{15,18}});\n        System.out.println(Arrays.deepToString(result));\n    }\n}"
    }
  }
]
